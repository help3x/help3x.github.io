---
lang: ja
pagetitle: "Note: SSL"
css:
- "https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css"
- "./default.css"
---

## 共通鍵暗号

暗号化と復号に同じ鍵（＝共通鍵）を使う。  
暗号化と復号の処理が軽い。  
送信者と受信者が、あらかじめ誰にも知られていない同じ鍵を持つ必要がある。  
鍵を他人に盗まれたらそれで復号されてしまうので、他人に知られない方法で受け渡さなければならない。  
 ... インターネットで送るなんてありえない。

```
送信者
↓
暗号化（秘密鍵）
↓
通信
↓
復号化（秘密鍵）
↓
受信者
```

## 公開鍵暗号

ペアになった公開鍵と秘密鍵を使う。  
片方の鍵で暗号化した内容は、その鍵とペアになっているもう片方の鍵でしか復号できない。  
片方の鍵をインターネットで公開しても、もう片方の鍵が非公開になっていれば安全にデータを送れる。

つまり、こういうこと。

* 公開鍵で暗号化した内容は、ペアとなる秘密鍵でしか復号できない。
* 秘密鍵で暗号化した内容は、ペアとなる公開鍵でしか復号できない。

```
送信者 <-----------------┐
↓                       ↑
暗号化（公開鍵）       復号化（公開鍵）
↓                       ↑
通信                   通信
↓                       ↑
復号化（秘密鍵）       暗号化（秘密鍵）
↓                       ↑
受信者 ------------------┘
        ※逆も同様。
```

## SSL通信の仕組み

共通鍵暗号と公開鍵暗号を組み合わせて通信する。

事前に公開鍵暗号を使って両者に共通鍵を持たせる。  
実際の通信は共通鍵を使って暗号化と復号化する。

#. クライアントからサーバーにSSL通信要求が来る。
#. サーバーがクライアントにサーバー証明書と自身の公開鍵を送信する。
#. クライアントは、サーバーから受信したサーバー証明書から公開鍵を取り出す。それを使って共通鍵を暗号化して送信する。
#. サーバーは自身の秘密鍵を使い、受信した内容を復号して、暗号通信に使う共通鍵を取り出す。

この段階で両者は暗号通信に必要な共通鍵を手に入れた。  
あとはこの共通鍵を使って暗号通信をする。


実際には共通鍵自身ではなく、共通鍵の基になる情報（プレマスタ・シークレット）を暗号化して送っている。


#. 接続要求 \
   クライアント側からSSL通信のリクエストをサーバ側へ送信。

#. SSLサーバ証明書と公開鍵をクライアント側へ送付 \
   サーバ側から、公開鍵付きのSSLサーバ証明書がクライアント側に送付。  
   クライアント側のブラウザに搭載されているルート証明書で署名を確認し、SSLサーバ証明書を検証。  
   ※グローバルサインをはじめとする「信頼のある認証局」のルート証明書は、あらかじめ主要PCブラウザや携帯端末に搭載されているので、ユーザ側で新たにインストールする必要がありません。 

#. 共通鍵(セッションキー）を暗号化しサーバ側へ送付 \
   クライアント側で生成された暗号用の「共通鍵(セッションキー）」を、サーバ側から送られてきた公開鍵を用いて暗号化し、サーバ側へ送信。  
   サーバ側に送信された共通鍵は、サーバ側で保持している秘密鍵で復号化され、共通鍵が取り出される。 

#. SSL暗号化通信開始 \
   個人情報などの機密性の高いデータを、クライアント側で保持している共通鍵で暗号化しサーバ側へ送信。  
   サーバ側は、受け取った暗号データをサーバ側で保持している共通鍵で復号してデータを取得する。  
   ※共通鍵は、サーバとクライアントが使用するブラウザの双方が対応する、最も強度の高い暗号方式・鍵長が使用されます。 



○データを守る  
送信するデータ＋取り出した公開鍵＝暗号化  
　→相手の持つ秘密鍵でしか見られない。

○相手を特定する  
受信したデータ＋自身の秘密鍵＝署名  
　→自分の証明書に含まれる鍵で開けられる。



## サーバー証明書

通信相手のサーバーが信頼できるかどうかを確認する仕組み。

サーバー証明書
:   サーバーの管理者が「認証局」と呼ばれる組織に申請して発行してもらう証明書。  
    発行組織名、有効期限、サーバーの公開鍵などが書き込まれている。  
    認証局の署名（証明書の内容を、認証局の秘密鍵で暗号化したデータ）が付いている。

申請＝CSR＝署名リクエスト（Certificate Signing Request）  
　サーバー証明書を取得するために認証局へ提出する申請書のようなもの。  
　サーバー証明書を導入するサーバーで生成する。  
　実体は暗号化されたテキストデータで、申請者の公開鍵と、運営者情報（ディスティングイッシュネーム）が含まれる。





## 署名した認証局がそもそも信頼できるのか？

クライアントにはサーバー証明書と一緒に、署名した認証局の証明書も送られている。
もし、認証局が別の認証局から署名を受けているときは、さらにその署名を受けた認証局の証明書も送られる。
最終的には最上位の「ルート認証局」と呼ばれる認証局の証明書が必ず送られてくる。

まずはルート認証局が信頼できるかを確認する。  
パソコンにはもともと信頼できるルート認証局の証明書（自己証明書）が複数インストールされている。  
それらとサーバーから受信した証明書が一致するかを確認し、一致したら受信した証明書は信頼できると判断する。  
信頼できた証明書から公開鍵を取り出し、そこから署名を受けた証明書を検証する。  
この流れを繰り返し、受信したすべての証明書を検証する。

具体的には次の内容が一致するかを検証する。

* 署名をルート認証局の公開鍵で復号したデータ
* サーバー証明書のハッシュ値


自己証明書＝自己署名証明書＝オレオレ証明書
自前の認証局＝オレオレ認証局＝プライベート認証局

認証局 ＝ CA ＝ Certificate Authority / Certification Authority





## 公開鍵基盤（PKI）

信頼できる第3者である認証局（CA）が、甲が本人であることを保証する仕組み。
甲が本人である＝甲本人だけが秘密鍵を保有し、公開鍵は電子証明書として公開すること

```
        申請                 電子証明書の有効性確認
 +------------> +--------+ <-----------+
 |  +---------- | 認証局 |             |
 |  ￬   発行    +--------+             |
+----+                               +----+
| 甲 | ----------------------------> | 乙 |
+----+         署名付きファイル      +----+
```

#. 甲が認証局に電子証明書の発行を依頼する。
#. 認証局は甲の本人確認をする。
#. 本人確認のあと、認証局は甲に電子証明書を発行する。電子証明書には公開鍵が含められる。

キーペア（公開鍵と秘密鍵）の作成は、認証局が生成する場合もあれば、甲自身が生成する場合もある。


Memo: （いずれも環境依存文字）  
　半角の上向き矢印: 0xFFEA ￪  
　半角の下向き矢印: 0xFFEC ￬





## 電子署名の仕組み

```
平文をハッシュ化した結果を秘密鍵で暗号化
↓
送信（平文、暗号文、公開鍵を含んだ電子証明書）
↓
通信
↓
受信
↓
平文をハッシュ化する。
↓
電子証明書が信頼できるか確認し、その中から公開鍵を取り出して暗号文を復号する。
↓
ハッシュ値と復号したデータが一致すれば送信された平文は甲本人が作成し、改ざんされていないことが証明できる。
```




## インターネットにおける4つのリスク

* なりすまし
* 改ざん
* 事後否認
* 盗聴

電子証明書
:   認証局と呼ばれる組織が、持ち主の身元情報を認証し発行する。

電子証明書に含まれるもの

* 証明書の発行者
* 有効期限
* 名前
* 鍵





## SSLサーバー証明書

ウェブサイトの運営者の実在性を確認し、ブラウザとサーバー間で通信データの暗号化を行うための電子証明書。  
認証局から発行される。  

* 運営者の情報
* 暗号化に必要な鍵
* 発行者の署名

なりすまし、盗聴、改ざんのリスク防止に有効。





## クライアント認証

システムやサービス、メールを利用するユーザーのデバイスに証明書をインストールし、そのユーザーが正規の利用者であることを認証する。

クライアント証明書の主な用途

* 証明書がインストールされていない端末から、システムにアクセスされるのを防ぐ。
    * 利用者が特定できるようになるので、毎回IDやパスワードを入力しなくてもよくなる。
* メールの送信主を証明し、なりすましや改ざん、盗聴を防ぐ。





## Windows 証明書サービス

公的な認証局から証明書を発給してもらうのは費用がかかる。  
社内システムなど特定少数ユーザーに対してのみサービスを提供するときは経済的ではない。  
そんなときに使う。  
　＝会社などの組織で内輪限定のサーバー証明書を用意したいという場面。

このサービスは誰でも自由に立ち上げられるので、公的な証明力はまったくない。  
インターネットで不特定多数に対して提供するサービスでは使えない。

留意事項

クライアントPCにも証明書サービスのCA証明書を配布する必要あり。  
デフォルトでオレオレ証明書がインストールされているわけないからね。

IISの制限

* 1つのWebサイトに割り当てられるサーバー証明書は1つだけです。
* 複数のWebサイトに同じサーバー証明書を割り当てることはできます。
* 同じWebサーバーでSSLの使用・不使用を使い分けるときは、SSLを使うWebサイトと使わないWebサイトに分けます。

Windows Server 2008 での証明書サービスの名前は「Active Directory 証明書サービス」です。  
サーバーマネージャで追加できます。

役割サービスは次の2つにチェックをつけます。

* 証明機関
* 証明機関Web登録

証明書サービスによって運営するCAは「スタンドアロンCA」を選択します。  
（「エンタープライズCA」はいつ使うんでしょうか？）

CAの種類の指定は「ルートCA」にします。

新しい秘密鍵を作成してください。

CAの共通名、証明書の有効期間などは規定値でいいでしょう。

最終的にウィザードの最終画面でインストールを選択すれば、証明書サービスの組み込みとCAの立ち上げが行われます。





## 参考

* [オレオレ認証局の作り方～SSL証明書を無料で作る方法 on CentOS 5](http://www.webtech.co.jp/blog/optpix_labs/server/1159/)
* [オレオレ認証局でクライアント認証 ～ ウェブの Basic 認証をリプレース](http://www.webtech.co.jp/blog/optpix_labs/server/1780/)
* にわか管理者のためのWindowsサーバ入門
    * [【第65回】証明書サービスとオレオレ証明書](https://news.mynavi.jp/itsearch/article/hardware/897)
    * [【第66回】証明書サービスからSSLサーバ証明書を導入する](https://news.mynavi.jp/itsearch/article/hardware/898)
    * [【第67回】オレオレ証明書を使用する際のクライアント側の作業](https://news.mynavi.jp/itsearch/article/hardware/899)
    * [【第68回】一般のCAからSSLサーバ証明書を導入する](https://news.mynavi.jp/itsearch/article/hardware/900)
* [IIS7.5をスタンドアロンルートCAで発行したクライアント認証証明書を要求するように設定する](http://blogs.gine2.jp/kusa/archives/2071)













