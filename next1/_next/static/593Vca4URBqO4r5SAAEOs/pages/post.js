(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{118:function(n,e,t){n.exports=t(43)},241:function(n,e,t){__NEXT_REGISTER_PAGE("/post",function(){return n.exports=t(242),{page:n.exports.default}})},242:function(n,e,t){"use strict";t.r(e);var o=t(0),r=t.n(o),p=t(9),a=t.n(p),c=t(118),s=t(35),i=t(23),d=t.n(i),l=t(22),u=t.n(l),g=function(n){var e="";n.pageContent.datePublished&&n.pageContent.datePublished.substr&&(e="".concat(n.pageContent.datePublished.substr(0,4),".").concat(("00"+n.pageContent.datePublished.substr(5,2)).slice(-2),".").concat(("00"+n.pageContent.datePublished.substr(8,2)).slice(-2)));var t="";return n.pageContent.datePublished&&(t=n.pageContent.datePublished),r.a.createElement(r.a.Fragment,null,r.a.createElement(u.a,null,r.a.createElement("title",{className:"jsx-3273275265"},n.pageContent.title," | ",n.siteName),r.a.createElement("meta",{name:"description",content:n.pageContent.description,className:"jsx-3273275265"})),r.a.createElement("article",{className:"jsx-3273275265 p2 md-pt3 md-px3 bg-white"},r.a.createElement("header",{className:"jsx-3273275265 article-header mb3"},r.a.createElement("h1",{className:"jsx-3273275265"},n.pageContent.title),r.a.createElement("div",{className:"jsx-3273275265 flex flex-wrap"},r.a.createElement("div",{className:"jsx-3273275265"},r.a.createElement("time",{dateTime:t,className:"jsx-3273275265 "},e)))),r.a.createElement("div",{dangerouslySetInnerHTML:{__html:n.pageContent.contentHtml},className:"jsx-3273275265 article-body"})),r.a.createElement(d.a,{styleId:"3273275265",css:["body{word-wrap:break-word;}",".article-header h1{font-size:2rem;line-height:1.25;}",".article-body h2{font-size:1.5rem;line-height:1.3333333333;margin-top:3rem;padding-top:1rem;padding-bottom:1rem;border-top:solid 1px #000;border-bottom:solid 1px #000;}",".article-body h3{font-size:1.25rem;line-height:1.4;padding-top:.75rem;}",".article-body h4{font-size:1rem;line-height:1.5;padding-top:1rem;}",".article-body h5{font-size:.875rem;line-height:1.5714285714;padding-top:1.125rem;}",".article-body h6{font-size:.75rem;line-height:1.6666666667;padding-top:1.25rem;}",".article-body div.sourceCode{margin:0;margin-left:-1rem;margin-right:-1rem;margin-bottom:1rem;padding:0;}",".article-body pre.sourceCode{madgin:0;padding:1rem;overflow-x:auto;color:#333;background:#f8f8f8;border:1px solid #ddd;border-radius:.25rem;font-size:.75rem;max-width:100%;}",".article-body code.sourceCode,pre>code{background-color:transparent;padding:0;}","@media all and (min-width:50em){.article-body div.sourceCode{margin-left:-2rem;margin-right:-2rem;}.article-body pre.sourceCode{padding-left:2rem;padding-right:2rem;}}"]}))},m=t(248),h=t.n(m);function y(){return(y=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n}).apply(this,arguments)}var R=Object(c.withRouter)(function(n){var e=a()().publicRuntimeConfig,t=n.router.query.id,o="/"===(t||"").substr(0,1)?t.substr(1):t||"",p={};if(o){var c=h.a.filter(function(n){return n.id===o});c.length>0&&(p=c[0])}return r.a.createElement(s.a,null,r.a.createElement(g,y({pageContent:p},e)))});e.default=R},248:function(n,e){n.exports=[{title:"[CSS3] ボックスに影をつける box-shadow プロパティ",datePublished:"2018-01-21T23:00+09:00",id:"css3-box-shadow",category:"雑記",contentHtml:'<h2 id="-">概要</h2>\n<p><code>box-shadow</code>プロパティは、ボックスに1つまたは複数の影をつけるときに使います。<code>box-shadow</code>プロパティでは、たとえば以下のように影を指定します。</p>\n<h2 id="-">コードサンプル</h2>\n<p><code>box-shadow: 10px 10px;</code></p>\n<h3 id="-">補足説明</h3>\n<p>影は２～４つの長さの値で定義されますが、任意で色、insetキーワードを指定することもできます。insetキーワードを付けると、影がボックスの外側ではなく内側につくようになります。 長さの指定を省略すると0となり、色の指定を省略するとユーザーエージェントが選んだ色になります。 複数の影を指定する場合には、カンマ（ , ）区切りで影のリストを複数指定します。</p>\n<p>影を定義する指定内容は、以下のように解釈されます。</p>\n<ul>\n<li>１番目の長さの値は、水平方向の影のオフセット距離です。正の値を指定すると右へ、負の値を指定すると左へ影が移動します。</li>\n<li>２番目の長さの値は、垂直方向の影のオフセット距離です。正の値を指定すると下へ、負の値を指定すると上へ影が移動します。</li>\n</ul>\n'},{title:"String (JavaScript)",datePublished:"2018-01-23T09:08+09:00",id:"javascript-string-prototype",category:"雑記",contentHtml:'<h2 id="string-prototype-substring-">String.prototype.substring()</h2>\n<p><strong><code>substring()</code></strong>メソッドは、0 インデックスやそのほか、または文字列の最後までの String オブジェクトの部分集合を返します。</p>\n<h2 id="-h2-string-prototype-codepointat-"><h2>String.prototype.codePointAt()</h2>\n<p><strong><code>codePointAt()</code></strong>メソッドは、Unicode ポイント値である負でない整数を返します。</p>\n'},{title:"React 事始め",datePublished:"2018-01-25T11:59+09:00",dateModified:"2018-03-16T11:10+09:00",id:"study-react",category:"雑記",contentHtml:'<h2 id="-">実施環境</h2>\n<ul>\n<li>Windows 7 Professional Service Pack 1</li>\n<li>node v8.9.4</li>\n<li>npm 4.0.5</li>\n<li>create-react-app 1.5.2</li>\n</ul>\n<h2 id="-">はじめに</h2>\n<p>React\n:   Webの見た目を作ることに特化したJavaScriptライブラリ。\n    Viewに関連する機能だけを持つ。</p>\n<p>Flux\n:   次のように、データの流れを一方向に限定する設計パターン。\n    不整合が発生しにくい仕組みになっている。</p>\n<pre><code>                  ┌─── Action ←─┐\n                  ↓                  ｜\n    Action → Dispatcher → Store → View\n\n&lt;!-- --&gt;\n\n1. View はユーザーの入力から Action を作成する。\n2. Action を Dispatch することで Store にデータを保存する。\n3. Store を View に反映する。\n</code></pre><p>Redux\n:   Fluxアーキテクチャの実装。</p>\n\x3c!--\n- View\n- Action\n- Store\n- Dispatcher\n- Reducer\n    状態を変化させるための関数です。Actionの内容によって既存の状態を変化させます。\n--\x3e\n<p>オブジェクトや配列の操作を行う場合は、基本的には参照渡しでなく値のコピーを渡します。\n参照を切る方法としてES2015で標準化された<code>Object.assign()</code>メソッドを使ってもよいです。</p>\n<p>Spread Operatorでも可。</p>\n<pre><code class="lang-javascript">return {\n  ...state,\n  status: 1,\n};\n</code></pre>\n<pre><code class="lang-javascript">return Object.assign({}, state, {\n  state: 1\n});\n</code></pre>\n<h2 id="create-react-app">Create React App</h2>\n<p><a href="https://github.com/facebook/create-react-app">GitHub - facebook/create-react-app</a></p>\n<h2 id="-">環境構築</h2>\n<h3 id="node-js-">node.jsのインストール</h3>\n<p>割愛します。</p>\n<p>Windowsユーザーであれば nodist を入れればよいかと。</p>\n<h3 id="create-react-app-">create-react-app のインストール</h3>\n<p>作業フォルダを作りその中にインストールします。</p>\n<pre><code>&gt; mkdir react1st &amp; cd react1st\n&gt; npm install create-react-app\n</code></pre><h3 id="-">アプリケーションの作成</h3>\n<p><code>create-react-app</code>コマンドを使ってアプリケーションを作成します。</p>\n<p>構文\n:   <code>create-react-app &lt;application-name&gt;</code></p>\n<p><code>my-app</code>アプリケーションを作成してみます。</p>\n<pre><code>&gt; .\\node_modules\\.bin\\create-react-app my-app\n</code></pre><p>作成されたアプリケーションの構成は以下のようになっています。</p>\n<pre><code>.\n+---node_modules\n+---public\n|   +---favicon.ico\n|   +---index.html\n|   `---manifest.json\n+---src\n|   +---App.css\n|   +---App.js\n|   +---App.test.js\n|   +---index.css\n|   +---index.js\n|   +---logo.svg\n|   `---registerServiceWorker.js\n+---.gitignore\n+---package.json\n`---README.md\n</code></pre><h3 id="-">開発モードでアプリケーションを起動</h3>\n<p>アプリケーションのルートフォルダ（<code>my-app</code>フォルダ）に移動し、<code>npm start</code>コマンドを実行します。\nブラウザが自動で起動し、アプリケーションが表示されます。\nもし、ブラウザが起動しなかったときは自分で起動して<code>http://localhost:3000/</code>にアクセスしてください。</p>\n<pre><code>&gt; cd my-app\n&gt; npm start\n</code></pre><h4 id="-">開発モードの機能</h4>\n<p>開発モードは次の動作になります。\n開発モードを終了するには、Control＋Cキーを押します。</p>\n<ul>\n<li>ソースコードの変更を監視し、アプリケーションを自動でビルドする。</li>\n<li>ブラウザを自動でリロードする。</li>\n<li>コンソールにビルドエラーとlintの警告を表示する。</li>\n</ul>\n<h3 id="hello-world-">Hello, World! の表示</h3>\n<p><code>src\\App.js</code>ファイルを以下のように編集します。</p>\n<pre><code class="lang-javascript">&lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;\n</code></pre>\n<p>↓</p>\n<pre><code class="lang-javascript">&lt;h1 className=&quot;App-title&quot;&gt;Hello, World!&lt;/h1&gt;\n</code></pre>\n<p>保存に伴い、ブラウザが自動でリロードされ、修正内容が反映されます。</p>\n<h2 id="jsx">JSX</h2>\n<p>JSX\n:   JavaScriptを拡張した言語。\n    ReactとJSXを一緒に使うことが推奨されています（必須ではない）。</p>\n<ul>\n<li>JSXでは、JavaScriptのなかにHTMLのタグや属性を（ほぼ）同じように書くことができる。</li>\n<li>最終的にトランスパイラでJavaScriptに変換して使う。\n  このとき、JSXに書いたタグは、<code>React.createElement</code>関数の呼び出しに変換される。</li>\n</ul>\n<p>トランスパイラ\n:   ソースコードを別のソースコードに変換するツールのことです。\n    BabelのほかCoffeeScriptやTypeScriptなどがあります。</p>\n<h3 id="jsx-">JSXの使い方</h3>\n<ul>\n<li><p>JSXのタグは<code>React.createElement</code>に変換されるため、Reactのインポートが必要です。</p>\n<pre><code>  import React from &#39;react&#39;;\n</code></pre></li>\n<li><p><code>{}</code>で囲むと式をJSXに埋め込むことができます。</p>\n<pre><code>  const fullnames = {\n    ryoma: &#39;坂本竜馬&#39;\n  };\n  const getFullname = nickname =&gt; fullnames[nickname];\n  const element = &lt;h1&gt;Hello, {getFullname(&#39;ryoma&#39;)}&lt;/h1&gt;;\n</code></pre></li>\n</ul>\n<h2 id="babel-">babelのインストール</h2>\n<ol>\n<li><p>作業ディレクトリを作り、その中に移動します。</p>\n<pre><code> &gt; mkdir babel-cli-example &amp; cd babel-cli-example\n</code></pre></li>\n<li><p>空のpackage.jsonを作ります。</p>\n<pre><code> &gt; echo {} &gt; package.json\n</code></pre></li>\n<li><p>Babel関連のパッケージをインストールします。</p>\n<pre><code> &gt; npm install --save-dev babel-cli babel-preset-react\n</code></pre></li>\n</ol>\n<p>babel-cli\n    BabelをCLI上で動作させるためのパッケージです。\n    Babelを使ったソースコードの変換を行うbabelコマンドと、変換に加えて変換後のソースコードをそのままNode.jsで実行するbabel-nodeコマンドを含んでいます。</p>\n<h3 id="react-">react向けに変換するコマンド</h3>\n<pre><code>.\\node_modules\\.bin\\babel [Options...] target-file\n</code></pre><p>e.g.,</p>\n<pre><code>.\\node_modules\\.bin\\babel --presets=react input.js\n</code></pre><p>標準出力ではなくファイルに出力するときは、<code>--out-file</code>オプションにファイル名を指定します。</p>\n<pre><code>.\\node_modules\\.bin\\babel --presets=react input.js --out-file output.js\n</code></pre><p>webpack\n:   モジュールバンドラー。<br>    ES ModulesやNode.jsで利用されているCommonJSのモジュール方式で記述されたソースファイルを束ねて、ブラウザで実行可能な静的なJavaScriptファイルを出力します。</p>\n<ol>\n<li><p>作業ディレクトリを作り、その中に移動します。</p>\n<pre><code> &gt; mkdir webpack-example &amp; cd webpack-example\n</code></pre></li>\n<li><p>空のpackage.jsonを作ります。</p>\n<pre><code> &gt; echo {} &gt; package.json\n</code></pre></li>\n<li><p>開発に使うパッケージをインストールします（<code>--save-dev</code>オプションをつけます）。</p>\n<pre><code> &gt; npm install --save-dev ^\n   webpack ^\n   webpack-cli ^\n   babel-loader ^\n   babel-core ^\n   babel-preset-react\n</code></pre></li>\n<li><p>実行に使うパッケージをインストールします（<code>--save</code>オプションをつけます）。</p>\n<pre><code> &gt; npm install --save ^\n   react ^\n   react-dom\n</code></pre></li>\n</ol>\n\x3c!--\n--save-devインストール\n\n- webpack\n- webpack-cli\n- babel-loader\n- babel-core\n- babel-preset-react\n\n--saveインストール\n\n- react\n- react-dom\n--\x3e\n<p>Webpackのバージョンを表示</p>\n<pre><code>.\\node_modules\\.bin\\webpack --version\n4.1.0\n</code></pre><p>Hello.js\n:   </p>\n<pre><code>~~~javascript\nimport React from &#39;react&#39;;\n\n// export default function で\n// Hello コンポーネントを持っていることを外部に知らせる\nexport default function Hello() {\n  return &lt;h1&gt;Hello! webpack&lt;/h1&gt;;\n}\n~~~\n</code></pre><p>entry.js\n:   </p>\n<pre><code>~~~javascript\nimport React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport Hello from &#39;./Hello&#39;;    // ← Hello.js の読み込み\n\nReactDOM.render(\n  &lt;Hello /&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n~~~\n</code></pre><p>importのパスが絶対パスでも相対パスでもない場合、webpackはnpmモジュールから読み込みます。</p>\n<p>webpack.config.js</p>\n<p>webpackの設定ファイルは、JSON、XML、YAMLなどのフォーマットを記述できます。<br>フォーマットの判別は設定ファイルの拡張子で行います。</p>\n<p>JavaScriptであれば、Node.jsのモジュールとして扱うので、<code>module.exports</code>に代入しているオブジェクトが設定ファイルとして利用されます。</p>\n<pre><code class="lang-javascript">module.exports = {\n  // entryフィールド\n  // 実行の起点となるファイルの指定\n  entry: &#39;./entry.js&#39;,\n\n  // outputフィールド\n  // 出力に関する設定\n  output: {\n    filename: &#39;output.js&#39;\n  },\n\n  module: {\n    rules: [\n      // babel-loader の設定\n      // ファイルごとに適応するLoaderの設定を書く\n      {\n        loader: &#39;babel-loader&#39;,\n        test: /\\.js$/,\n        options: {\n          presets: [&#39;react&#39;]\n        }\n      }\n    ]\n  }\n};\n</code></pre>\n<p>webpackを実行</p>\n<p><code>dist\\output.js</code>が出力されます。</p>\n<pre><code>&gt; .\\node_modules\\.bin\\webpack --config webpack.config.js\n</code></pre><p><code>dist\\index.html</code>を作成します。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;ja&quot;&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n&lt;title&gt;webpack test&lt;/title&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;\n  &lt;script src=&quot;./output.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>ブラウザで表示。</p>\n<p><code>output.js</code>の読み込みだけで表示されました。\n動作に必要なスクリプト（<code>react.min.js</code>や<code>react-dom.min.js</code>）が、webpackによってすべて<code>output.js</code>に束ねられているからです。</p>\n<h2 id="react-">Reactコンポーネント</h2>\n<p>create-react-app による開発は、自動作成された「src\\index.js」や、その中で読み込んでいる「src\\App.js」を編集して動作を確かめます。\nファイルやフォルダを分けてコードを管理するのもありです。</p>\n<h3 id="react-">Reactコンポーネントの種類</h3>\n<h4 id="functional-component">Functional Component</h4>\n<p>関数によって定義されるコンポーネント。</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\n\nconst Hello = (props) =&gt; {\n  return &lt;div&gt;こんにちは、{props.name}さん&lt;/div&gt;;\n};\n</code></pre>\n<h4 id="class-component">Class Component</h4>\n<p>クラスによって定義されるコンポーネント。</p>\n<pre><code class="lang-javascript">class Hello extends React.Component {\n  render() {\n    return &lt;div&gt;こんにちは、{this.props.name}さん&lt;/div&gt;;\n  }\n};\n</code></pre>\n<h5 id="functional-component-">Functional Componentとの違い</h5>\n<ul>\n<li><code>React.Component</code>を明示的に継承している。</li>\n<li>propsの受け取り方がthis.propsとなっている。</li>\n<li>コンポーネントの状態を記録する仕組みがある（state）。</li>\n<li>ライフサイクルメソッドという特殊なメソッドが定義できる。</li>\n</ul>\n<h3 id="-">コンポーネントの再利用</h3>\n<pre><code class="lang-javascript">const Hello = () =&gt; {\n  return &lt;div&gt;こんにちは、坂本竜馬さん&lt;/div&gt;;\n};\n\nReactDOM.render(\n  &lt;div&gt;\n    &lt;Hello /&gt;\n    &lt;Hello /&gt;\n    &lt;Hello /&gt;\n  &lt;/div&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n</code></pre>\n<p>Reactコンポーネント\n:   設計図のようなもの。\n    オブジェクト指向でいえば〝クラス〟にあたる。</p>\n<p>Reactエレメント\n:   設計図（Reactコンポーネント）を元に作られた実体のこと。\n    オブジェクト指向でいえば〝インスタンス〟にあたる。</p>\n<pre><code class="lang-javascript">// こちらはReactコンポーネント\nconst Hello = () =&gt; {\n  return &lt;div&gt;こんにちは、坂本竜馬さん&lt;/div&gt;;\n};\n\nReactDOM.render(\n  &lt;div&gt;\n    { /* 以下のHello3つはどれも React エレメント */ }\n    &lt;Hello /&gt;\n    &lt;Hello /&gt;\n    &lt;Hello /&gt;\n  &lt;/div&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n</code></pre>\n<h3 id="fragment-">Fragmentコンポーネント</h3>\n<p>Reactコンポーネントは単一の親からなる要素しか表現できません。\n複数の要素をラップする要素を使ってもよいのですが、これではもともと表現したかったHTML構造にならないことがあります。</p>\n<p>React.Fragmentコンポーネントを使うとこの制約をクリアすることができます。</p>\n<p>↓ ダメな例</p>\n<pre><code class="lang-javascript">const Hello = () =&gt; {\n  return (\n    &lt;div&gt;こんにちは&lt;/div&gt;\n    &lt;div&gt;坂本竜馬さん&lt;/div&gt;\n  );\n};\n</code></pre>\n<p>↓ ラップして対処する方法</p>\n<pre><code class="lang-javascript">const Hello = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;div&gt;こんにちは&lt;/div&gt;\n      &lt;div&gt;坂本竜馬さん&lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre>\n<p>↓ <code>React.Fragment</code>で対処する方法</p>\n<pre><code class="lang-javascript">const Hello = () =&gt; {\n  return (\n    &lt;React.Fragment&gt;\n      &lt;div&gt;こんにちは&lt;/div&gt;\n      &lt;div&gt;坂本竜馬さん&lt;/div&gt;\n    &lt;/React.Fragment&gt;\n  );\n};\n</code></pre>\n<h3 id="-props-">データの受け渡し（props）</h3>\n<pre><code class="lang-javascript">const Hello = (props) =&gt; {\n  return &lt;div&gt;こんにちは、{props.name}さん&lt;/div&gt;;\n};\n\nReactDOM.render(\n  &lt;div&gt;\n    &lt;Hello name=&quot;A&quot; /&gt;\n    &lt;Hello name=&quot;B&quot; /&gt;\n    &lt;Hello name=&quot;C&quot; /&gt;\n  &lt;/div&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n</code></pre>\n<p>Helloの関数の引数に<code>props</code>を追加します。引数の名前はなんでもいいですが、<code>props</code>にするのが一般的。</p>\n<p><code>props</code>の引数にはコンポーネントを使う側で指定した内容が入ります。</p>\n<p>上記でいえば、<code>&lt;Hello name=&quot;A&quot; /&gt;</code>として使っているので、<code>props</code>には<code>name</code>というプロパティが追加され、「A」が格納されます。同様に<code>&lt;Hello name=&quot;B&quot; /&gt;</code>であれば、<code>props.name</code>の値は「B」になります。</p>\n<p><code>props</code>には文字列、数値、配列、オブジェクト、関数など任意の値を指定できます。\n渡す値は<code>{}</code>で囲みます。</p>\n<pre><code class="lang-javascript">// 文字列\n&lt;Component stringValue={ &quot;坂本竜馬&quot; } /&gt;\n\n// 数値\n&lt;Component numberValue={42} /&gt;\n\n// 真偽値\n&lt;Component boolValue={true} /&gt;\n\n// 配列\n&lt;Component arrayValue={[&quot;Aさん&quot;, &quot;Bさん&quot;, &quot;Cさん&quot;]} /&gt;\n\n// オブジェクト\n&lt;Component objectValue={{name: &quot;Aさん&quot;, birthDay: &quot;1836/01/03&quot;}} /&gt;\n\n// 関数\n&lt;Component funcValue={(name) =&gt; console.log(name);} /&gt;\n\n// 変数\nconst name = &quot;Aさん&quot;;\n&lt;Component value={name} /&gt;\n\n// 複数の値も渡せます\n&lt;Component name={ &quot;Aさん&quot; } birthDay={ new Date(1836, 0, 3) } /&gt;\n</code></pre>\n<p><code>props.children</code></p>\n<p>Reactコンポーネントの子要素が渡されるプロパティです。</p>\n<p>次の場合、<code>props.children</code>には「坂本竜馬」が渡されます。</p>\n<pre><code class="lang-javascript">const Hello = (props) =&gt; {\n  return &lt;div&gt;こんにちは、{props.children}さん&lt;/div&gt;;\n};\n\nReactDOM.render(\n  &lt;div&gt;\n    &lt;Hello&gt;\n      坂本竜馬      ←Helloコンポーネントの子要素が渡される\n    &lt;/Hello&gt;\n  &lt;/div&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n</code></pre>\n<h3 id="props-">propsの型チェック</h3>\n<p>コンポーネントがどのようなpropsを受け取るのか記述することができます。\nインターフェイスに合わない値が渡されたときに、エディタや実行時に警告を受け取ることができます。</p>\n<p>別パッケージになっているので追加でインストールします。</p>\n<pre><code>&gt; npm install --save prop-types\n</code></pre><p>ReactコンポーネントのpropTypesプロパティに型情報を記述します。\nFunctional Component/Class Componentのどちらでも記述できます。</p>\n<pre><code class="lang-javascript">import PropTypes from &#39;prop-types&#39;;\n\nconst Hello = (props) =&gt; {\n  return &lt;div&gt;こんにちは、{props.name}さん&lt;/div&gt;;\n};\n\n// ここに型情報を書きます\n// ↓\nHello.propTypes = {\n  name: PropTypes.string    // nameの型はstring\n}\n</code></pre>\n<p>propTypesの種類</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport PropTypes from &#39;prop-types&#39;;\n\nclass SomeComponent extends React.Component {\n}\n\nSomeComponent.propTypes = {\n  someString: PropTypes.string, // 文字列\n  someNumber: PropTypes.number, // 数値\n  someBool:   PropTypes.bool,   // 真偽値\n  someArray:  PropTypes.array,  // 配列\n  someObject: PropTypes.object, // オブジェクト\n  someFunc:   PropTypes.func,   // 関数\n  someSymbol: PropTypes.symbol, // シンボル\n\n  // 配列の中身を指定\n  someArray2: PropTypes.arayOf(PropTypes.number),\n\n  // オブジェクトの中身を指定\n  someObj2:   PropTypes.objectOf(PropTypes.number),\n\n  // オブジェクトの個別のプロパティの中身を指定\n  someObj3:   PropTypes.shape({\n    name: PropTypes.string,\n    age:  PropTypes.number\n  }),\n\n  // Reactエレメント\n  someElement: PropTypes.element,\n\n  // コンポーネントの子要素となるもの\n  // （string, number, element, array ならOK）\n  someNode: PropTypes.node,\n\n  // Helloコンポーネントのインスタンスを指定\n  helloElement: PropTypes.instanceOf(Hello),\n\n  // 指定した値のいずれかであること\n  dayOfTheWeek: PropTypes.oneOf([&quot;月&quot;, &quot;火&quot;, &quot;水&quot;]),\n\n  // 配列で指定した型のいずれかであること\n  union: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Hello),\n  ]),\n\n  // 何でもオーケー\n  any: PropTypes.any,\n\n  // 必須項目\n  requiredString: PropTypes.string.isRequired,\n\n  // どんな型でもいいから何かしら指定\n  requiredAny: PropTypes.any.isRequired,\n};\n\n// propsの値が undefined だったときの規定値を指定する\nSomeComponent.defaultProps = {\n  name: &quot;坂本竜馬&quot;    // name が undefined のときに設定する内容\n};\n</code></pre>\n<p><code>Array.map</code>メソッド\n:   配列の各要素について、引数に与えられた関数の処理に従って処理をし、新たな配列を返すメソッド。</p>\n<pre><code>~~~javascript\n// tasksの各要素をTodoItemコンポーネントにして返す\nconst list = this.props.tasks.map(todo =&gt; {\n  return &lt;TodoItem {...todo} key={todo.id} /&gt;;\n});\n~~~\n</code></pre><h3 id="state-">stateの初期値</h3>\n<p><code>constructor</code>で設定します。</p>\n<pre><code class="lang-javascript">constructor(props) {\n  super(props);\n  this.state = {\n    tasks: [\n      { title: &quot;Todo-1&quot;, id: 0 },\n      { title: &quot;Todo-2&quot;, id: 1 },\n    ],\n    uniqueId: 1,\n  };\n}\n</code></pre>\n<ul>\n<li><code>state</code>の名前は変更できません。</li>\n<li><code>this.state</code>に直接値を入れていいのは<code>constructor</code>で初期値を設定するときだけです。\n  それ以外の場面で直接編集してしまうと、Reactコンポーネントに値の変更を通知することができません。</li>\n<li><code>this.state</code>を更新するときは<code>this.setState</code>メソッドを使います。\n  いまあるstateと比べて、変更があった内容を反映します。stateをごっそり置き換えるわけではありません。</li>\n<li><code>this.state</code>を直接参照するのはありです。</li>\n</ul>\n<pre><code class="lang-javascript">constructor(props) {\n  ...略\n\n  // bindメソッド\n  // 指定したメソッドでAppコンポーネントのstateを変更するために必要\n  // ↓\n  this.methodName = this.methodName.bind(this);\n</code></pre>\n<p><code>bind</code>メソッド\n:   関数の中で使用する<code>this</code>を強制する（バインドする）メソッド。</p>\n<pre><code>methodNameメソッドを実行するのは、Appコンポーネントではない別のコンポーネントやDOMになります。\nそれらのコンテキストである`this`には`state`が存在しないのでエラーが発生します。\n</code></pre><p>ほかのバインドの方法</p>\n<ul>\n<li><p>アロー関数を使う</p>\n<p>  アロー関数を使うときは、constructorにbindメソッドを書く必要がありません。\n  ですが、同じメソッドを複数のコンポーネントに渡したい場合、その数だけアロー関数を書く必要があります。</p>\n<p>  毎回新しいアロー関数を作ることになるので、パフォーマンスも少し劣ります。</p>\n<pre><code class="lang-javascript">  // アロー関数を使う\n  &lt;Component methodName={ (hoge) =&gt; { this.methodName(hoge) } } /&gt;\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>property initializer syntax を使う</p>\n<p>  最初からバインドされたメソッドを作ることができます。\n  アロー関数のようなパフォーマンスの懸念もありません。</p>\n<p>  ただし、ECMAScriptに公式なシンタックスとして採用されていないため、babelにプラグインを追加しておく必要があります。</p>\n<p>  Class properties transform・Babel（transform-class-properties）</p>\n</li>\n</ul>\n<h3 id="-">イベントハンドリング</h3>\n<p>イベントハンドラを追加します。</p>\n<p>下記の例では、クリック時のイベントを<code>handleClick</code>メソッドに定義しています。\nイベントとの関連付けは、button要素のonClick属性に<code>handleClick</code>メソッドを設定しています。</p>\n<p>Reactでは<code>onClick</code>といった属性に関数を渡して、イベントの関連付けをします。</p>\n<pre><code class="lang-javascript">constructor(props) {\n  super(props);\n  this.handleClick = this.handleClick.bind(this);   // バインドする\n}\n// Eventオブジェクトを引数に持つ\nhandleClick(e) {\n  this.props.methodName(&quot;hoge&quot;);\n}\nrender() {\n  return (\n    &lt;div&gt;\n      &lt;input placeholder=&quot;何か入力してください&quot; /&gt;\n      &lt;button onClick={ this.handleClick } &gt;登録&lt;/button&gt;\n  );\n}\n</code></pre>\n<p>イベントハンドラの引数は、Eventオブジェクトを受け取ります。\nブラウザ本来のEventオブジェクトとほぼ同じものです。</p>\n<h3 id="form-">formの操作</h3>\n<p>Reactではフォームに入力された値も<code>state</code>として扱います。</p>\n<p>以下は、ユーザーの入力で state を変更するコードです。</p>\n<pre><code class="lang-javascript">constructor(props) {\n  super(props);\n  this.state = {\n    inputValue: &quot;&quot;,\n  };\n  this.handleChange = this.handleChange.bind(this);\n  this.handleClick = this.handleClick.bind(this);\n}\nhandleChange(e) {\n  // ユーザーの入力した値をstate.inputValueに格納する\n  this.setState({\n    inputValue: e.target.value,\n  });\n}\nhandleClick() {\n  const inputValue = this.state.inputValue;\n  this.props.methodName(inputValue);\n}\nrender() {\n  return (\n    &lt;div className=&quot;TodoInput&quot;&gt;\n      ▼valueにstate.inputValueを設定、onChangeにhandleChangeメソッドを関連付け\n      &lt;input placeholder=&quot;何か入力してください&quot; value={this.state.inputValue} onChange={this.handleChange} /&gt;\n      &lt;button onClick={this.handleClick} &gt;登録&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h3 id="-react-">まとめ:  Reactコンポーネントの作成手順</h3>\n<ol>\n<li>UIをコンポーネントに分割する</li>\n<li>propsやstateによって、どのようにUIが変化するかを定義する（JSXの作成）</li>\n<li>ユーザー操作によって、どのようにstateが変化するかを定義する（メソッドの作成）</li>\n<li>UIとメソッドを関連付ける（onClick属性などを設定）</li>\n</ol>\n<p>コンポーネントごとの責務を明らかにすること。</p>\n<h3 id="-">ライフサイクル</h3>\n<p>Reactコンポーネントにはライフサイクルメソッドと呼ばれる特殊なメソッドがあります。\nReactコンポーネントの状態に応じて、次の3つのうち対応するメソッドが呼ばれます。</p>\n<ul>\n<li>コンポーネントのマウントに対応して呼ばれるメソッド。</li>\n<li>コンポーネントで扱うデータの変化に対応して呼ばれるメソッド。</li>\n<li>エラーハンドリングに用いるメソッド。</li>\n</ul>\n<h4 id="-">マウントに関するライフサイクルメソッド</h4>\n<p>Reactコンポーネントが新しく配置されるときに呼び出されるメソッドです。\nコンポーネントの<code>render</code>メソッドが初めて呼ばれたときに、コンポーネントがマウントされた状態となります。</p>\n<ul>\n<li>コンポーネントのマウント ＝ コンポーネントの<code>render</code>メソッドが初めて呼ばれたとき</li>\n<li>コンポーネントのアップデート ＝ 2回目以降の<code>render</code>メソッドの呼び出し</li>\n<li>コンポーネントのアンマウント ＝ DOM上からなくなったとき</li>\n</ul>\n<p>componentWillMount\n:   コンポーネントがマウントされる直前に呼ばれます。\n    コンポーネントを描画する<code>render</code>メソッドよりも先に呼ばれます。</p>\n<pre><code>ただ、コンストラクターも`render`メソッドより先に呼ばれるので、マウント前にしたい処理はここではなくコンストラクターで実行すれば十分です。\n</code></pre><p>componentDidMount\n:   コンポーネントがマウントされた直後に呼ばれます。\n    DOMがブラウザにレンダリングされたあとなので、DOMに対してイベントリスナーを設定したりサブスクライブなどの処理をしたりします。</p>\n<pre><code>TODO: サブスクライブって何でしょう？？\n\n`setState`は行わないこと。\n\nstateが変更されるとrenderメソッドが実行されます。\nrender → componentDidMount → setState → renderとなり、renderメソッドが2回実行されてしまうためです。\n</code></pre><p>componentWillUnmount\n:   コンポーネントがアンマウントされる直前に呼ばれます。\n    各種コンポーネントに関連付けた処理の後始末をします。</p>\n<pre><code>たとえば、setInterval関数に対するclearIntervalの実行や、APIリクエストのキャンセルなどです。\n</code></pre><h4 id="-">データのアップデートに関するライフサイクルメソッド</h4>\n<p>アップデートはコンポーネントのpropsかstateが変更されたときに行われます。\n初回のレンダリングはマウントとして扱われるため、マウント時にはこれらのメソッドは実行されません。</p>\n<p>componentWillReceiveProps\n:   引数に受け取る予定のpropsをとります。</p>\n<pre><code>~~~javascript\ncomponentWillReceiveProps(nextProps)\n~~~\n\npropsがアップデートされようとしているときのみ実行されます。\npropsの受け取りで実行されるため、変更の有無は関係なく実行されます。\n\nthis.propsには以前に受け取ったpropsが入っています。\n引数のnextPropsと比較する処理をすることができます。\n\nsetStateをすることも可能です。\n</code></pre><p>shouldComponentUpdate\n:   propsやstateに変更が合った場合に呼ばれます。\n    引数は次に受け取るpropsとstateです。\n    this.propsとthis.stateには前回の内容が入っています。</p>\n<pre><code>~~~javascript\nshouldComponentUpdate(nextProps, nextStaet)\n~~~\n\nrenderを行うべきかどうかをtrue/falseで返す必要があります。\n\nこのメソッドを指定しなかった場合、どのような変更でもrenderメソッドが呼び出されます（常にtrueを返すように指定したのと同じ）。\n\nこのメソッドはパフォーマンスチューニングをする際に利用します。\n表示に使っていないpropを受け取ったときや、そもそもpropsやstateに変更がなかったときは不要なrenderを行わないようにします。\n\n変更がないpropやstateを受け取ったときに再描画させないようにするもう一つの方法。\n\n`React.Component`を継承する代わりに`React.PureComponent`を継承すると、Reactが自動的に浅い比較（オブジェクトや配列の中身までは確認しない比較）を行うので、通常はこちらを利用する方が便利です。\nなにか特別な比較を行い、renderの有無を決めるときだけ`shouldComponentUpdate`を利用することを推奨します。\n</code></pre><p>componentWillUpdate\n:   renderが呼ばれる前に呼ばれる最後のメソッドです。</p>\n<pre><code>引数は次に受け取るpropsとstateです。\nthis.propsとthis.stateには前回の内容が入っています。\n\n~~~javascript\ncomponentWillUpdate(nextProps, nextStaet)\n~~~\n\n`setState`などコンポーネントの再レンダリングを促すような処理はしないこと。\n変更に対して`componentWillUpdate`、`render`が実行され、処理がループする可能性があるためです。\n\npropsの値を使ってstateを変更したいときは`componentWillReceiveProps`メソッドを使います。\n\n`shouldComponentUpdate`でfalseを返した場合、このメソッドは呼ばれません。\n</code></pre><p>componentDidUpdate\n:   renderの直後に呼ばれます。</p>\n<pre><code>引数は前のpropsとstateです。\nthis.propsとthis.stateは、いまの値（renderに使った内容）が格納されています。\n\n~~~javascript\ncomponentDidUpdate(prevProps, prevStaet)\n~~~\n\nアップデート後のDOMにアクセスするときや、変更が完了したことをAPIに通知するときなどに利用します。\n\n`shouldComponentUpdate`でfalseを返した場合、このメソッドは呼ばれません。\n</code></pre><h4 id="-">エラーハンドリングに関するライフサイクルメソッド</h4>\n<p>エラーが起きたときだけ呼ばれるライフサイクルメソッドです。\nReact v16 から実装されています。</p>\n<p>componentDidCatch\n:   子コンポーネントでエラーが起こったときに呼ばれます。</p>\n<pre><code>~~~Javascript\ncomponentDidCatch(error, info)\n~~~\n\n引数にスタックとレースが入ったerror、その他の情報が入ったinfoをとります。\n\ninfoはオブジェクトで、現時点では`componentStack`プロパティしか持っていません。\nこれにはどのコンポーネントでエラーが発生したかが入っています。\n\nエラー解析の手がかりとなるので、どちらもログとして送信するようにしておくと便利。\n\n`setState`などの処理を行うことも可能。\n\nこのメソッドを記述したコンポーネント自体のエラーは検知できません。\n子コンポーネントのエラーを検知するためのメソッドです。\n</code></pre><h2 id="redux-">Reduxによるアプリケーションの状態管理</h2>\n<p><code>create-react-app</code>で新しいアプリケーションを作成します。</p>\n<h3 id="redux-">Reduxのインストール</h3>\n<pre><code>&gt; npm install --save redux\n</code></pre><h3 id="redux-">Reduxの構成</h3>\n<p>Store\n:   アプリケーションの状態（<code>state</code>）とロジックを保持している居場所。</p>\n<p>Reducer\n:   Storeが保持している状態を変化させるための関数。</p>\n<p>Action\n:   何らかの状態変化を引き起こす現象。たとえば、ユーザー入力、APIから取得した情報。</p>\n<pre><code>Actionの形式を標準化した〝Flux Standard Action〟というものがあります。\nActionを扱うライブラリ（`redux-actions`や`redux-promise`など）でも、これを採用したものが多いので、この形式に沿っておくのがよいでしょう。\n\nActionオブジェクトには、次のプロパティを持たせることができます。\n\n- type\n\n  必須プロパティです。\n  どのような操作をしたのかが分かる内容を指定します。\n\n- payload\n\n  Actionに伴うデータ。オブジェクト形式で扱うのが一般的。\n  errorプロパティがtrueのときはErrorオブジェクトを返すべき。\n\n- error\n\n  エラーを表現するときはtrueにします。\n\n- meta\n\n  payloadとは別に、ほかの情報をActionとして含めたいときに使う項目です。\n</code></pre><h3 id="reducer-">Reducerの定義</h3>\n<p>Storeの初期状態［index.js］</p>\n<pre><code class="lang-javascript">const initialState = {\n  tasks: []\n};\n</code></pre>\n<p>tasksReducerの定義［index.js］</p>\n<pre><code class="lang-javascript">// Reducerの定義\n// 第1引数は、現在の状態を表すstateオブジェクト\n// 第2引数は、どのような操作をしたのかを示すActionオブジェクト\nfunction tasksReducer(state = initialState, action) {\n  switch (action.type) {\n    case &#39;ADD_TASK&#39;:\n      return {\n        ...state,\n        tasks: state.tasks.concat([action.task])    // TODO: action.payload.taskでは？　→　そのとおりでした。\n      };\n    default:\n      return state;\n  }\n}\n</code></pre>\n<p>Actionオブジェクトのイメージ</p>\n<pre><code class="lang-javascript">{\n  type: &#39;ADD_TASK&#39;,\n  payload: {\n    task: &#39;Study Reducer&#39;\n  }\n}\n</code></pre>\n<h3 id="actioncreator-">ActionCreatorの定義</h3>\n<p>ActionCreatorとはActionを生成するための関数です。</p>\n<p>Actionを生成する関数の定義［index.js］</p>\n<pre><code class="lang-javascript">// ActionCreatorの定義\n// 追加するtaskを引数に取り、Actionオブジェクトを返す\nconst addTask = (task) =&gt; ({\n  type: &#39;ADD_TASK&#39;,\n  payload: {\n    task\n  }\n});\n</code></pre>\n<h3 id="store-">Storeの定義</h3>\n<p>Reduxの<code>createStore</code>関数を使ってStoreを生成します。\n生成したStoreはアプリケーション内で唯一のものです。\nアプリケーション全体のさまざまな状態をこのStoreで集約管理します。</p>\n<p>ReduxのStoreを生成するにはReducerが必要となります。</p>\n<p>Storeの作成［index.js］</p>\n<pre><code class="lang-javascript">import { createStore } from &#39;redux&#39;;\n\n// Reducerの定義\nfunction tasksReducer(state = initialState, action) {\n  // ...略\n}\n\n// Storeの生成\nconst store = createStore(tasksReducer);\n</code></pre>\n<pre><code class="lang-javascript">createStore(reducer, [preloadedState], [enhancer])\n</code></pre>\n<p>引数</p>\n<p>reducer\n:   Reducerを指定します。</p>\n<p>preloadedState\n:   Storeの初期値を指定します。\n    サーバーサイドやユーザーセッションで事前にデータを保持しているときに利用することが想定されます。</p>\n<p>enhancer\n:   Storeの機能を拡張するサードパーティ製のツールを指定できます。</p>\n<p>戻り値</p>\n<p>Storeオブジェクト</p>\n<p>Storeオブジェクトは次の4つのメソッドを持ちます。</p>\n<ul>\n<li><p>dispatch</p>\n<p>  ActionCreatorで生成したActionを発行します。</p>\n<pre><code class="lang-javascript">  // ActionCreatorの定義\n  const addTask = (task) =&gt; ({\n    ... 略\n  });\n\n  store.dispatch(addTask(&quot;Study Store&quot;));\n</code></pre>\n</li>\n<li><p>getState</p>\n<p>  Storeの現在の状態を取得します。</p>\n<pre><code class="lang-javascript">  console.log(store.getState());\n  ↓\n  {\n    tasks: [&#39;Study Store&#39;]\n  }\n</code></pre>\n</li>\n<li><p>subscribe</p>\n<p>  Storeの状態が変更されたときに呼び出されるコールバック関数を指定します。</p>\n<p>  ActionのdispatchによってStoreの状態が変わったときに、その変換を監視する役目を担う処理。</p>\n<p>  <code>store.subscribe</code>で監視を開始します。\n  <code>store.subscribe</code>の戻り値である<code>unsubscribe</code>を実行することで、<code>subscribe</code>を解除することができます。</p>\n<p>  実際にReactと組み合わせるときは、<code>react-redux</code>というライブラリを使います。\n  <code>react-redux</code>が<code>subscribe</code>の仕組みを隠蔽するため、Storeの状態が変化するとReactのViewが更新されるというシンプルな流れになります。</p>\n<pre><code class="lang-javascript">  function handleChange() {\n    console.log(store.getState());\n  }\n\n  // Storeの状態が変化したときに handleChange 関数が呼ばれる。\n  // subscribeの戻り値は unsubscribe という関数。\n  // これを実行すると状態変化の通知が解除され、handleChange 関数は呼ばれなくなる。\n  const unsubscribe = store.subscribe(handleChange);\n</code></pre>\n</li>\n<li><p>replaceReducer</p>\n<p>  createStoreで関連付けたReducerを、別のReducerに差し替えるメソッドです。</p>\n<p>  createStoreで関連付けることができるReducerは1つだけです。\n  複数あるReducerを動的にロードしたいときにこのメソッドで差し替えをします。</p>\n<p>  Storeに関連付けられているReducerのみしか適用されないので、特別な理由がない限り、combineReducerによって一つにまとめたReducerを関連付けてしまう方が楽。</p>\n</li>\n</ul>\n<pre><code>combineReducer\n:   Reduxに備わっているメソッドで、複数のReducerを合成します。\n\n    通常、一つのReducer内で処理分岐して定義して問題ありませんが、規模が大きくなってくると見通しが悪くなってくるのでReducerを分割したくなります。\n    そんなときにどうぞ。\n\n    Storeはアプリケーション内で一つということに変わりはありませんが、Reducerを分割することで、Storeを擬似的に分割できる点がメリットです。\n</code></pre><h3 id="react-">Reactと組み合わせる</h3>\n<p>次の機能を持たせます。</p>\n<ul>\n<li>Reactを使って状態の変化をViewに反映する。</li>\n<li>ブラウザからのタスク入力を可能にする。</li>\n</ul>\n<ol>\n<li><p>タスク入力用のActionCreatorの定義</p>\n<pre><code class="lang-javascript"> // タスク入力用のActionCreator\n const inputTask = (task) =&gt; ({\n   type: &quot;INPUT_TASK&quot;,\n   payload: {\n     task\n   }\n });\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>タスク入力用のActionを受け取りStoreを変更できるように、Reducerを変更する</p>\n<pre><code class="lang-javascript"> const initialState = {\n   task: &quot;&quot;,       // ←追加\n   tasks: []\n };\n\n function tasksReducer(state = initialState, action) {\n   switch (action.type) {\n     case &#39;INPUT_TASK&#39;:    // INPUT_TASKのCaseを追加\n       return {\n         ...state,\n         task: action.payload.task\n       };\n     case &#39;ADD_TASK&#39;:\n       return {\n         ...state,\n         tasks: state.tasks.concat([action.payload.task])\n       };\n     default:\n       return state;\n   }\n }\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>Reactコンポーネントの定義を追加する</p>\n<pre><code class="lang-javascript"> function TodoApp({ store }) {\n   const { task, tasks } = store.getState();\n   return (\n     &lt;div&gt;\n       &lt;input type=&quot;text&quot; onChange={(e) =&gt; store.dispatch(inputTask(e.target.value))} /&gt;\n       &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; store.dispatch(addTask(task))} /&gt;\n       &lt;ul&gt;\n         {\n           tasks.map(function(item, i) {\n             return (\n               &lt;li key={i}&gt;{item}&lt;/li&gt;\n             );\n           })\n         }\n       &lt;/ul&gt;\n     &lt;/div&gt;\n   );\n }\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>Reactコンポーネントを描画する関数の準備</p>\n<p> importを次のように変更する。</p>\n<pre><code class="lang-javascript"> import ReactDOM from &#39;react-dom&#39;;\n</code></pre>\n<p> ↓</p>\n<pre><code class="lang-javascript"> import { render } from &#39;react-dom&#39;;\n</code></pre>\n<p> Viewを描画する関数を追加する。</p>\n<pre><code class="lang-javascript"> function renderApp(store) {\n   render(\n     &lt;TodoApp store={store} /&gt;,\n     document.getElementById(&#39;root&#39;)\n   );\n }\n</code></pre>\n<p> もともとあった描画の処理は削除する。</p>\n<pre><code class="lang-javascript"> ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));\n registerServiceWorker();\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>Viewに反映する関数の準備</p>\n<p> Storeの状態変化に応じてViewを変化させる関数を定義します。\n Storeの<code>subscribe</code>メソッドを使います。</p>\n<pre><code class="lang-javascript"> store.subscribe(() =&gt; renderApp(store));\n</code></pre>\n<p> 上記処理の次に描画する関数の呼び出しを追加する。<br> 初期表示用？</p>\n<pre><code class="lang-javascript"> renderApp(store);\n</code></pre>\n</li>\n</ol>\n<h3 id="index-js-">index.jsの全体</h3>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { createStore } from &#39;redux&#39;;\n\n// Note: 使わないのでコメント化 &gt;&gt;&gt;\n// import &#39;./index.css&#39;;\n// import App from &#39;./App&#39;;\n// import registerServiceWorker from &#39;./registerServiceWorker&#39;;\n/// Note: &lt;&lt;&lt; 使わないのでコメント化\n\nconst initialState = {\n  task: &quot;&quot;,\n  tasks: []\n};\n\n// Reducerの定義\n// 第1引数は、現在の状態を表すstateオブジェクト\n// 第2引数は、どのような操作をしたのかを示すActionオブジェクト\nfunction tasksReducer(state = initialState, action) {\n  switch (action.type) {\n    case &#39;INPUT_TASK&#39;:\n      return {\n        ...state,\n        task: action.payload.task\n      };\n    case &#39;ADD_TASK&#39;:\n      return {\n        ...state,\n        tasks: state.tasks.concat([action.payload.task])\n      };\n    default:\n      return state;\n  }\n}\n\n\n// Storeの生成\nconst store = createStore(tasksReducer);\n\n// ActionCreatorの定義\n// 追加するtaskを引数に取り、Actionオブジェクトを返す\nconst addTask = (task) =&gt; ({\n  type: &#39;ADD_TASK&#39;,\n  payload: {\n    task\n  }\n});\n\n\n// タスク入力用のActionCreator\nconst inputTask = (task) =&gt; ({\n  type: &quot;INPUT_TASK&quot;,\n  payload: {\n    task\n  }\n});\n\n\nfunction TodoApp({ store }) {\n  const { task, tasks } = store.getState();\n  return (\n    &lt;div&gt;\n      &lt;input type=&quot;text&quot; onChange={(e) =&gt; store.dispatch(inputTask(e.target.value))} /&gt;\n      &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; store.dispatch(addTask(task))} /&gt;\n      &lt;ul&gt;\n        {\n          tasks.map(function(item, i) {\n            return (\n              &lt;li key={i}&gt;{item}&lt;/li&gt;\n            );\n          })\n        }\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n\n\nfunction renderApp(store) {\n  render(\n    &lt;TodoApp store={store} /&gt;,\n    document.getElementById(&#39;root&#39;)\n  );\n}\n\n\nstore.subscribe(() =&gt; renderApp(store));\nrenderApp(store);\n</code></pre>\n<h3 id="-">ファイルを機能ごとに分割する</h3>\n<p>ActionCreator、Store、Reducer、Componentの定義を、1ファイルにまとめて書きました。\nこれを役割ごとにファイルを分割したほうが視認性がよくなります。</p>\n<p>次のフォルダ構造でファイルを分割します。</p>\n<pre><code>src/\n+---index.js\n+---containers/\n|     ... Container Component を置く\n+---components/\n|     ... Presentational Component を置く\n+---actions/\n|     ... ActionCreator を置く\n`---reducers/\n      ... Reducer を置く\n</code></pre><ol>\n<li><p>Reducerの定義を<code>src/reducers/tasks.js</code>に移動します。</p>\n<p> function には <code>export default</code> を付けてください。</p>\n<pre><code class="lang-javascript"> const initialState = {\n   task: &quot;&quot;,\n   tasks: []\n };\n\n // Reducerの定義\n // 第1引数は、現在の状態を表すstateオブジェクト\n // 第2引数は、どのような操作をしたのかを示すActionオブジェクト\n export default function tasksReducer(state = initialState, action) {\n   switch (action.type) {\n     case &#39;INPUT_TASK&#39;:\n       return {\n         ...state,\n         task: action.payload.task\n       };\n     case &#39;ADD_TASK&#39;:\n       return {\n         ...state,\n         tasks: state.tasks.concat([action.payload.task])\n       };\n     default:\n       return state;\n   }\n }\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>ActionCreatorの定義を <code>src/actions/tasks.js</code> に移動します。</p>\n<p> const に <code>export</code> を付けてください。</p>\n<p> ~~~javascript\n // ActionCreatorの定義\n // 追加するtaskを引数に取り、Actionオブジェクトを返す\n export const addTask = (task) =&gt; ({\n   type: &#39;ADD_TASK&#39;,\n   payload: {</p>\n<pre><code> task\n</code></pre><p>   }\n });</p>\n</li>\n</ol>\n<pre><code>// タスク入力用のActionCreator\nexport const inputTask = (task) =&gt; ({\n  type: &quot;INPUT_TASK&quot;,\n  payload: {\n    task\n  }\n});\n~~~\n</code></pre><ol>\n<li><p>Componentの定義を <code>src/components/TodoApp.js</code> に移動します。</p>\n<p> componentsからActionをDispatchするため、先ほど移動したActionCreatorのファイルをインポートします。</p>\n<p> （<code>import { inputTask, addTask } from &#39;../actions/tasks&#39;;</code> の部分）</p>\n<p> 関数には <code>export default</code> を付けてください。</p>\n<pre><code class="lang-javascript"> import React from &#39;react&#39;;\n import { inputTask, addTask } from &#39;../actions/tasks&#39;;\n\n export default function TodoApp({ store }) {\n   const { task, tasks } = store.getState();\n   return (\n     &lt;div&gt;\n       &lt;input type=&quot;text&quot; onChange={(e) =&gt; store.dispatch(inputTask(e.target.value))} /&gt;\n       &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; store.dispatch(addTask(task))} /&gt;\n       &lt;ul&gt;\n         {\n           tasks.map(function(item, i) {\n             return (\n               &lt;li key={i}&gt;{item}&lt;/li&gt;\n             );\n           })\n         }\n       &lt;/ul&gt;\n     &lt;/div&gt;\n   );\n }\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p><code>src\\index.js</code> は、分割したファイルをインポートするように変更します。</p>\n<pre><code class="lang-javascript"> import React from &#39;react&#39;;\n import { render } from &#39;react-dom&#39;;\n import tasksReducer from &#39;./reducers/tasks&#39;;    // Reducerのインポート\n import TodoApp from &#39;./components/TodoApp&#39;;     // Componentのインポート\n import { createStore } from &#39;redux&#39;;\n\n // Note: 使わないのでコメント化 &gt;&gt;&gt;\n // import &#39;./index.css&#39;;\n // import App from &#39;./App&#39;;\n // import registerServiceWorker from &#39;./registerServiceWorker&#39;;\n /// Note: &lt;&lt;&lt; 使わないのでコメント化\n\n // Storeの生成\n const store = createStore(tasksReducer);\n\n function renderApp(store) {\n   render(\n     &lt;TodoApp store={store} /&gt;,\n     document.getElementById(&#39;root&#39;)\n   );\n }\n\n store.subscribe(() =&gt; renderApp(store));\n renderApp(store);\n</code></pre>\n</li>\n</ol>\n\x3c!-- TODO: p.108 「最終的な」と書いておきつつ、サンプルコードに最後の2行がない。 --\x3e\n<h3 id="react-redux">react-redux</h3>\n<p><code>react-redux</code>は、ReactとReduxの連携をサポートするライブラリです。\nStoreの状態変化に応じて該当部分のViewを再描画するのを手助けしてくれます。</p>\n<h3 id="react-redux-">react-reduxのインストール</h3>\n<pre><code>&gt; npm install --save react-redux\n</code></pre>\x3c!-- TODO: p109 `-save`になっている。半角ハイフンがひとつ足りない。 --\x3e\n<p>ReactはViewを扱うライブラリなので、Reduxが有するStoreやActionの情報と疎結合になっていることが望ましい。\nそのほうがコンポーネント単体としてもテストしやすいし、コードの可読性も上がります。</p>\n<p>Container Component\n:   Reactコンポーネントをラップしたコンポーネント。</p>\n<pre><code>ReduxのStoreやActionを受け取り、ReactのPropsとして渡す役を担います。\nContainer Componentの責務は、ReactとReduxの橋渡しのみなので、JSXを記述するのは誤りです。\n</code></pre><p>Presentational Component\n:   Redux依存のない純粋なReactコンポーネント。</p>\n<h3 id="react-redux-">react-reduxの機能</h3>\n<p>次の2つの機能があります。</p>\n<ul>\n<li>&lt;Provider&gt;</li>\n<li>connect</li>\n</ul>\n<h4 id="-lt-provider-store-gt-">&lt;Provider store&gt;</h4>\n<p>dispatchはStoreが持つメソッドなので、ReactコンポーネントからActionをdispatchさせるにはStoreが必要になります。\ndispatchしたいコンポーネントすべてに対し、Storeを最上位から渡していくのは得策ではありません。</p>\n<p>&lt;Provider&gt;を使うことで<code>connect</code>という関数を使えるようになり、任意のコンポーネントに対してStoreとの紐付けができるようになります。</p>\n<pre><code class="lang-javascript">// 最上位のコンポーネントを&lt;Provider&gt;でラップして、propsにStoreを与える\n// （内部的にはReactのcontext経由でStoreを保持する仕組み）\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;MyRootComponent /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n</code></pre>\n<h4 id="connect-mapstatetoprops-mapdispatchtoprops-mergeprops-options-">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</h4>\n<p>特定のComponentに対して、Reactのcontextで保持しているStoreを提供します。\nStoreさえあれば<code>getState</code>で状態が取得できますし、Actionの<code>dispatch</code>もできます。</p>\n<p>引数</p>\n<p>mapStateToProps(state, [ownProps])\n:   Storeから必要なstateを取り出し、ComponentのPropsに割り当てる関数を指定します。</p>\n<pre><code>第1引数はStoreのstate。\n複数のReducerを組み合わせている場合は、必要な部分のstateのみ取り出して返すようにすれば、不要なコンポーネントを渡さずに済みます。\n\n第2引数はオプションで、親コンポーネントから引き継がれてきたPropsが格納されています（下記の例では未使用）。\n\n~~~javascript\nfunction mapStateToProps({ task, tasks }) {\n  return {\n    task,\n    tasks,\n  };\n}\n~~~\n\n戻り値のオブジェクトは、connect先のComponentのPropsとして受け取ることができます。\n</code></pre><p>mapDispatchToProps(dispatch, [ownProps])\n:   Actionのdispatchを行う処理を指定します。そうすることでコンポーネントからdispatchの概念を隠蔽します。</p>\n<pre><code>第1引数に、Storeのdispatchメソッドが渡されてくるので、これを使ってActionをdispatchします。\n\n~~~javascript\n// ActionCreator\nconst addTask = (task) =&gt; ({\n  type: &quot;ADD_TASK&quot;,\n  payload: {\n    task\n  }\n});\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    addTask(task) {\n      dispatch(addTask(task));\n    }\n  };\n}\n~~~\n\n&lt;!-- TODO: p.112 dispatch(addTask(task});　← } ではなく ) では？ --&gt;\n</code></pre><p>mergeProps(stateProps, dispatchProps, ownProps)\n:   <code>mapStateToProps</code>と<code>mapDispatchToProps</code>を経たそれぞれのPropsと、親から渡ってきた<code>ownProps</code>をマージして、コンポーネントに渡します。</p>\n<pre><code>既定では、以下のように、`Object.assign`関数を使って単純に3つをマージしたものを返す処理が設定されています。\n\n~~~javascript\nfunction mergeProps(stateProps, dispatchProps, ownProps) {\n  return Object.assign({}, ownProps, stateProps, dispatchProps);\n}\n~~~\n</code></pre><p>options\n:   オプションとして次の項目を設定できます。</p>\n<pre><code>pure - Boolean\n:   規定値はtrueです。trueの場合、関連するState/Propsに変化がなければ、connectは再描画および`mapStateToProps`/`mapDispatchToProps`/`mergeProp`を呼び出しません。\n</code></pre>\x3c!-- TODO: p.114 mapStateToPrupsになっている。Propsでは？ --\x3e\n<pre><code>areStateEqual - Function\n:   `pure`がtrueの場合、Storeの中身の差分判定をどのようにするか指定します。\n    規定値は、strictEqual（===）です。\n\nareOwnPropsEqual - Function\n:   pureがtrueの場合、OwnPropの中身の差分判定をどのようにするか指定します。\n    規定値は、shallowEqual（==）です。\n\nareStatePropsEqual - Function\n:   pureがtrueの場合、mapStateToPropsの結果の差分判定をどのようにするか指定します。\n    規定値は、shallowEqual（==）です。\n\nareMergedPropsEqual - Function\n:   pureがtrueの場合、mergePropsの結果の差分判定をどのようにするか指定します。\n    規定値は、shallowEqual（==）です。\n\nstoreKey - String\n:   もし何らかの理由でStoreを複数用意したいときに指定します。\n\n    通常であれば不要。\n</code></pre><h3 id="react-redux-">react-reduxの組み込み</h3>\n<h4 id="container-component-">Container Componentの作成</h4>\n<p>ファイル<code>src\\containers\\TodoApp.js</code>を作ります。</p>\n<p>これにより TodoApp コンポーネントには Prop として次の4つが渡されるようになります。</p>\n<ul>\n<li>task - フォームに入力されたタスク</li>\n<li>tasks - タスクの配列</li>\n<li>addTask - タスクを追加する関数</li>\n<li>inputTask - タスクを入力する関数</li>\n</ul>\n<pre><code class="lang-javascript">import { connect } from &#39;react-redux&#39;;\nimport TodoApp from &#39;../components/TodoApp&#39;;\nimport { inputTask, addTask } from &#39;../actions/tasks&#39;;\n\n// Storeにある task と tasks という State を Props に渡す\nfunction mapStateToProps({ task, tasks }) {\n  return {\n    task,\n    tasks\n  };\n}\n\n// 該当のActionをDispatchさせる関数を Props に渡す\nfunction mapDispatchToProps(dispatch) {\n  return {\n    addTask(task) {\n      dispatch(addTask(task));\n    },\n    inputTask(task) {\n      dispatch(inputTask(task))\n    }\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n</code></pre>\n<h4 id="todoapp-">TodoAppコンポーネントの修正</h4>\n<p><code>src/components/TodoApp.js</code></p>\n<p>変更前\n:   StoreがPropsに渡ってきて、そこからStateを取得。</p>\n<p>変更後\n:   containersから整形されたオブジェクトがPropsとして渡されてきます。\n    ActionCreatorやActionのDispatchもcontainers側でやるので、コンポーネント側はPropsで渡ってきたinputTaskとaddTaskを呼び出すだけになります。</p>\n<pre><code>これにより、コンポーネントのRedux依存が消え、再利用性も高まりました。\n</code></pre><pre><code class="lang-javascript">import React from &#39;react&#39;;\n\n// 引数を store から変更\nexport default function TodoApp({ task, tasks, inputTask, addTask }) {\n  // onChange、onClickの指定時にdispatchが不要になる\n  return (\n    &lt;div&gt;\n      &lt;input type=&quot;text&quot; onChange={(e) =&gt; inputTask(e.target.value)} /&gt;\n      &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; addTask(task)} /&gt;\n      &lt;ul&gt;\n        {\n          tasks.map(function(item, i) {\n            return (\n              &lt;li key={i}&gt;{item}&lt;/li&gt;\n            );\n          })\n        }\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h4 id="index-js-">index.jsの修正</h4>\n<ul>\n<li>Providerのimportを追加</li>\n<li>TodoAppのimportをcomponentsではなくcontainersにする</li>\n<li>Storeのsubscribeでコンポーネントの再描画を行っていた処理を削除する</li>\n<li>function renderApp の処理を外に出す（render()をfunctionではなくする）</li>\n</ul>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport { Provider } from &#39;react-redux&#39;;\nimport { createStore } from &#39;redux&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport tasksReducer from &#39;./reducers/tasks&#39;;\nimport TodoApp from &#39;./containers/TodoApp&#39;;\n\n// Note: 使わないのでコメント化 &gt;&gt;&gt;\n// import &#39;./index.css&#39;;\n// import App from &#39;./App&#39;;\n// import registerServiceWorker from &#39;./registerServiceWorker&#39;;\n/// Note: &lt;&lt;&lt; 使わないのでコメント化\n\n// Storeの生成\nconst store = createStore(tasksReducer);\n\n// &lt;Provider&gt;を追加\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;TodoApp /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n</code></pre>\n<h4 id="connectadvanced">connectAdvanced</h4>\n<p>通常の<code>connect</code>よりも自由度を高くpropsの受け渡しをしたい場合、<code>connectAdvanced</code>を使うことができます。</p>\n<p><code>mapStateToProps</code>や<code>mapDispatchToProps</code>、<code>mergeProps</code>のあたりの処理を自前で行うイメージです。</p>\n<pre><code class="lang-javascript">connectAdvanced(selectorFactory, [connectOptions])\n</code></pre>\n<p>これらについては必要なときに調べるとしましょう。</p>\n<h2 id="-">ルーティング</h2>\n<p>ユーザーからの入力をもとに表示させるページを出し分けることをルーティングといいます。</p>\n<p>実装の方法は、どのページにいるのかという情報（URL）をStoreで保持し、変化があった場合にViewを差し替えるようにします。</p>\n<h3 id="-">実装パターン</h3>\n<p>URL遷移なし\n:   URLを使わずにアプリの内部で状態を保持する方法。</p>\n<pre><code>たとえば、Storeにpageというプロパティを用意し、ここでいまどのページにいるのかを管理します。\nですが、画面のリロードによって状態が元に戻ってしまうため現実的ではありません。\n</code></pre><p>URL Hash\n:   URL Hash（<code>#</code>)を使ってクライアントサイドのルーティングを実現する方法です。</p>\n<pre><code>aタグによるページ内移動と同じ仕組みなので、サーバーにリクエストは投げられません。\n\nHashは`location.hash`で取得できます。\nhashが変更されたときに発火する`hashchange`イベントをハンドリングしてコンポーネントを描画します。\n</code></pre><p>history API\n:   ブラウザの履歴情報を操作するAPI（history API）を使った方法です。</p>\n<pre><code>- `pushState`で履歴を追加できます。このとき、サーバーにリクエストは飛びません。\n- 画面をリロードされたときは、その時点のURLにリクエストが投げられます。そのため、URLに該当するリソースがないと404エラーになってしまいます。\n- 404エラーに対応するため、サーバーサイトで常にSPAの基点となるべきテンプレートを返すようにします。\n- `webpack-dev-server`を使っているときは、History API Fallback機能を使うとWebサーバーが返すリソースがない場合、自動で index.html を返してくれます。\n- Reduxのconnectを使っている場合は`connect-history-api-fallback`というミドルウェアを使います。\n</code></pre><h3 id="-">ルーティングライブラリ</h3>\n<p>React Router V4\n:   メジャーなルーティングライブラリ。react-nativeを使ったアプリ開発でも使うことができます。</p>\n<pre><code>Webアプリでは`react-router-dom`パッケージを使います。\n</code></pre><h4 id="-">インストール</h4>\n<pre><code>&gt; npm install --save react-router-dom\n</code></pre><p>react-router-redux\n:   react-routerをReduxに最適化したもの。</p>\n<pre><code>- react-routerのみでは、URLの変更を`&lt;Link&gt;`や`&lt;Redirect&gt;`経由でしかできません。\n- react-router-reduxでは、ルーティング情報をStoreのStateで管理しつつ、pushやreplaceといったAPIを使ってURLを変更できます。\n</code></pre><h4 id="-">インストール</h4>\n<p>react-routerも動作に必要です。react-router-domパッケージも一緒にインストールします。</p>\n<p>Note:\n:   react-router 4.x を使う場合、react-router-redux 5.x が必要です。\n    react-router-reduxに〝@next〟をつけてインストールします。</p>\n<pre><code>[react-router-redux - Installation](https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux#installation) より。\n</code></pre><pre><code>&gt; npm install --save react-router-dom react-router-redux@next history\n</code></pre><h4 id="-">特徴</h4>\n<ul>\n<li>react-routerのAPIはそのまま利用できます。</li>\n<li>react-router-reduxがやっていることは、historyオブジェクトを強化し、その変更をStoreのStateに常に同期することです。</li>\n</ul>\n<h4 id="-">導入方法</h4>\n<p>Storeの生成処理が複雑なので別ファイルとして切り出します。\nその中にStoreを生成する関数を定義します。</p>\n<p><code>src/store/index.js</code>というファイルを作成します。</p>\n<pre><code class="lang-javascript">import {\n  // 名前が被るので別名でインポートする\n  createStore as reduxCreateStore,\n  combineReducers,\n  applyMiddleware\n} from &#39;redux&#39;;\nimport { routerReducer, routerMiddleware } from &#39;react-router-redux&#39;;\nimport tasksReducer from &#39;../reducers/tasks&#39;;\n\n// Storeを生成するための関数を定義\n// historyはsrc/index.jsからもらう\nexport default function createStore(history) {\n  return reduxCreateStore(\n    combineReducers({\n      // tasksReducersをtasksというキーに割り当てる\n      tasks: tasksReducer,\n      // react-router-reduxのReducer\n      router: routerReducer\n    }),\n    applyMiddleware(\n      // react-router-reduxのRedux Middleware\n      routerMiddleware(history)\n    )\n  );\n}\n</code></pre>\n<ul>\n<li>react-router-reduxは<code>routerReducer</code>というルーティングのためのReducerを持っています。</li>\n<li>自前のReducerと一緒に使うために、combineReducerを使ってReducerを合成します。</li>\n<li>react-router-reduxはルーティングのための<code>routerMiddleware</code>というMiddlewareも提供しています。\nこのMiddlewareにより、ReduxのAction経由でルーティングを制御できるようになります。</li>\n<li><code>applyMiddleware</code>を使って、<code>routerMiddleware</code>を適用します。</li>\n</ul>\n<p>Storeの生成</p>\n<p><code>src/index.js</code>を変更します。</p>\n<ul>\n<li><code>import { createStore } from &#39;redux&#39;;</code>を消す。</li>\n<li><code>import tasksReducer from &#39;./reducers/tasks&#39;;</code> を消す。</li>\n<li><code>react-router-redux</code>と<code>history</code>、<code>src/store/index.js</code>のインポートを追加。</li>\n<li>historyのインスタンス生成を追加。</li>\n<li><ConnectedRouter>にhistoryを渡す処理を追加。</li>\n<li>createStoreの引数を<code>tasksReducer</code>から<code>history</code>に変更。</li>\n</ul>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport { Provider } from &#39;react-redux&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { ConnectedRouter } from &#39;react-router-redux&#39;;             // 追加\nimport createBrowserHistory from &#39;history/createBrowserHistory&#39;;  // 追加\nimport TodoApp from &#39;./containers/TodoApp&#39;;\nimport createStore from &#39;./store&#39;;                                // 追加\n\n// Note: 使わないのでコメント化 &gt;&gt;&gt;\n// import &#39;./index.css&#39;;\n// import App from &#39;./App&#39;;\n// import registerServiceWorker from &#39;./registerServiceWorker&#39;;\n/// Note: &lt;&lt;&lt; 使わないのでコメント化\n\n// history のインスタンスを生成\nconst history = createBrowserHistory();\n\n// Storeの生成\nconst store = createStore(history);\n\n// &lt;ConnectedRouter&gt;を追加\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;ConnectedRouter history={history}&gt;\n      &lt;TodoApp /&gt;\n    &lt;/ConnectedRouter&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n</code></pre>\n<p><code>src/store/index.js</code>でReducerの合成をしたため、Reducerの構成が変更になっています。</p>\n<p>Storeの構成</p>\n<p>↓</p>\n<pre><code class="lang-javascript">{\n  tasks: {\n    task: &quot;&quot;,\n    tasks: []\n  },\n  router: {\n    location: {\n      // ルーティング情報\n    }\n  }\n}\n</code></pre>\n<p>そのため、<code>src/containers/TodoApp.js</code>の<code>mapStateToProps</code>も変更する必要があります。</p>\n<pre><code class="lang-javascript">function mapStateToProps({ tasks }) {\n  return {\n    task: tasks.task,\n    tasks: tasks.tasks\n  };\n}\n</code></pre>\n<h4 id="action-">Action経由によるルーティング</h4>\n<p><code>routerMiddleware</code>を適用することで、Action経由でルーティングをすることができます。</p>\n<p><code>react-router-redux</code>が用意している次のようなActionCreatorを用いたルーティングができるようになります。</p>\n<p>push\n:   履歴に新しいlocationを追加します。</p>\n<p>replace\n:   現在の履歴を新しいlocationに置き換えます。</p>\n<p>go\n:   相対値（1 や -2 など）を指定して、履歴を移動します。</p>\n<p>goForward\n:   履歴を1つ進めます。</p>\n<p>goBack\n:   履歴を1つ戻ります。</p>\n<h4 id="-">ボタンを押すとエラーページに移動するサンプル</h4>\n<p><code>src/components/Error.js</code>ファイルを作成します。</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport { Link } from &#39;react-router-dom&#39;;\n\nexport default function Error() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;エラーページ&lt;/h1&gt;\n      &lt;Link to=&quot;/&quot;&gt;戻る&lt;/Link&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p><code>src/index.js</code>を変更して、エラーページに移動できるようにします。</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { Route } from &#39;react-router-dom&#39;;     // 追加\nimport { Provider } from &#39;react-redux&#39;;\nimport { ConnectedRouter } from &#39;react-router-redux&#39;;\nimport createBrowserHistory from &#39;history/createBrowserHistory&#39;;\nimport TodoApp from &#39;./containers/TodoApp&#39;;\nimport Error from &#39;./components/Error&#39;;       // 追加\nimport createStore from &#39;./store&#39;;\n\n// Note: 使わないのでコメント化 &gt;&gt;&gt;\n// import &#39;./index.css&#39;;\n// import App from &#39;./App&#39;;\n// import registerServiceWorker from &#39;./registerServiceWorker&#39;;\n/// Note: &lt;&lt;&lt; 使わないのでコメント化\n\n// history のインスタンスを生成\nconst history = createBrowserHistory();\n\n// Storeの生成\nconst store = createStore(history);\n\n// &lt;ConnectedRouter&gt;を追加\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;ConnectedRouter history={history}&gt;\n      &lt;div&gt;\n        { /* ルーティングさせる */ }\n        &lt;Route exact path=&quot;/&quot; component={TodoApp} /&gt;\n        &lt;Route exact path=&quot;/error&quot; component={Error} /&gt;\n      &lt;/div&gt;\n    &lt;/ConnectedRouter&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n</code></pre>\n<p><code>react-router-dom</code>のRouteコンポーネントを使ってルーティングを用意しています。</p>\n<p><code>/</code> であれば、Todoアプリを表示。\n<code>/error</code>であれば、エラーページを表示。</p>\n<p><code>src/containers/TodoApp.js</code>にエラーページにリダイレクトさせる処理を追加します。</p>\n<pre><code class="lang-javascript">import { connect } from &#39;react-redux&#39;;\nimport { push } from &#39;react-router-redux&#39;;    // 追加\nimport TodoApp from &#39;../components/TodoApp&#39;;\nimport { inputTask, addTask } from &#39;../actions/tasks&#39;;\n\n// Storeにある task と tasks という State を Props に渡す\nfunction mapStateToProps({ tasks }) {\n  return {\n    task: tasks.task,\n    tasks: tasks.tasks\n  };\n}\n\n// 該当のActionをDispatchさせる関数を Props に渡す\nfunction mapDispatchToProps(dispatch) {\n  return {\n    addTask(task) {\n      dispatch(addTask(task));\n    },\n    inputTask(task) {\n      dispatch(inputTask(task))\n    },\n    // リダイレクト処理を追加\n    // react-router-reduxが提供しているpushというActionCreatorを使う\n    redirectToError() {\n      dispatch(push(&#39;/error&#39;));\n    },\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n</code></pre>\n<p>リダイレクトする処理を呼び出せるように、<code>src/components/TodoApp.js</code>を変更します。</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\n\n// 引数に redirectToError を追加\nexport default function TodoApp({ task, tasks, inputTask, addTask, redirectToError }) {\n  return (\n    &lt;div&gt;\n      &lt;input type=&quot;text&quot; onChange={(e) =&gt; inputTask(e.target.value)} /&gt;\n      &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; addTask(task)} /&gt;\n      &lt;ul&gt;\n        {\n          tasks.map(function(item, i) {\n            return (\n              &lt;li key={i}&gt;{item}&lt;/li&gt;\n            );\n          })\n        }\n      &lt;/ul&gt;\n      { /* 追加 */ }\n      &lt;button onClick={() =&gt; redirectToError()}&gt;エラーページへ移動&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h2 id="redux-middleware">Redux Middleware</h2>\n<p>Redux Middleware とは、Reduxの機能を拡張する仕組みです。</p>\n<p>Middleware ＝ 拡張機能</p>\n<p>Redux自体は軽量なアーキテクチャなので、単体では提供していない機能もある。</p>\n<ul>\n<li>Actionのログを取るミドルウェア</li>\n<li>非同期処理を可能にするミドルウェア</li>\n<li>クラッシュレポートを送信するためのミドルウェア</li>\n<li>ルーティングのためのミドルウェア</li>\n<li>etc...</li>\n</ul>\n<h3 id="action-">Actionのログを取るミドルウェア</h3>\n<p><code>redux-logger</code>はActionがDispatchされる前後のstateと、DispatchされたActionをコンソールに表示します。\n開発時に有用なミドルウェアなのでインストールしたほうがよいでしょう。</p>\n<h4 id="-">インストール</h4>\n<pre><code>&gt; npm install --save redux-logger\n</code></pre>\x3c!-- TODO: p.143 install が insta\'l になっている --\x3e\n<h4 id="-">ミドルウェアの適用</h4>\n<p>Reduxにミドルウェアを適用するには、<code>applyMiddleware</code>関数を利用します。</p>\n<pre><code class="lang-javascript">// ミドルウェアの適用に必要な applyMiddleware 関数をインポートします\nimport { createStore, applyMiddleware } from &#39;redux&#39;;\n\n// ミドルウェアをインポートします\nimport logger from &#39;redux-logger&#39;;\n\n// createStoreの第2引数に applyMiddleware を指定し、その引数にミドルウェアを指定します\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n);\n</code></pre>\n<p><code>applyMiddleware</code>の引数は可変数なので、複数のミドルウェアを指定するときは、以下のようにカンマ区切りで並べて指定します。</p>\n<pre><code class="lang-javascript">applyMiddleware(middleware1, middleware2, middleware3)\n</code></pre>\n<h2 id="-">非同期処理</h2>\n<h3 id="-">同期処理と非同期処理</h3>\n<p>同期処理\n:   書いた順に実行される処理</p>\n<pre><code>~~~Javascript\nconsole.log(&quot;start&quot;);\nconsole.log(1 + 1);\nconsole.log(&quot;end&quot;);\n~~~\n</code></pre><p>非同期処理\n:   必ずしも書いた順には実行されない処理</p>\n<pre><code>~~~javascript\nconsole.log(&quot;start&quot;);\nsetTimeout(function () {\n  console.log(1 + 1);\n}, 1000);\nconsole.log(&quot;end&quot;);\n~~~\n\n非同期処理のあとに任意の処理を実行する方法として、コールバック関数やPromise、Async/Awaitなどがあります。\n</code></pre><h3 id="redux-thunk-">redux-thunkによる非同期処理</h3>\n<p>ReduxではAPIから何かレスポンスが返ってきたら、これをActionとして扱うという作法があります。\nこれを通常のActionCreatorで記述しようとすると、実はうまく書けません。</p>\n<pre><code class="lang-javascript">const requestAPI = (parameter) =&gt; {\n  const response = \n    fetch(&#39;APIのURL&#39;, parameter).then((response) =&gt; {\n      // ここで返してもうまく動かない\n      return {\n        type: &quot;REQUEST_API&quot;,\n        data: response\n      };\n    });\n};\n</code></pre>\n<p>Action自体は単なるオブジェクトです。これをstore.dispatch()に与えることでActionが実行されます。\nどうにかしてdispatch関数をコード中で使いたい。というときにこのミドルウェアの出番です。</p>\n<h3 id="thunk-">thunk ミドルウェア</h3>\n<p>Reduxで非同期処理をする代表的なミドルウェア。</p>\n<pre><code>&gt; npm install --save redux-thunk\n</code></pre><p>インストールできたらミドルウェアを適用します。</p>\n<pre><code class="lang-javascript">import { createStore, applyMiddleware } from &#39;redux&#39;;\nimport logger from &#39;redux-logger&#39;;\nimport thunk from &#39;redux-thunk&#39;;\nimport reducers from &#39;./reducers&#39;;\n\nconst middlewares = [logger, thunk];\n\nconst store = createStore(\n  reducers,\n  applyMiddleware(...middlewares)\n);\n\nexport default store;\n</code></pre>\n<h3 id="-">非同期アクション</h3>\n<p>thunkミドルウェアの適用により、非同期で実行されるActionを書けるようになりました。</p>\n<p>次のコードサンプルで使っているshortidパッケージはユニークなIDを自動で生成してくれるものです。\nインストールは <code>npm install --save shortid</code> でできます。</p>\n<pre><code class="lang-javascript">import shortid from &#39;shortid&#39;;\n\nimport * as types from &#39;../types/todo&#39;;\n\n// 同期 ActionCreator\nexport function addTodo(title) {\n  return {\n    type: types.ADD_TODO,\n    payload: {\n      id: shortid.generate(),\n      title\n    },\n  };\n}\n\n// 非同期 ActionCreator\nexport function asyncAddTodo(title) {\n  return (dispatch, getState) =&gt; {\n    setTimeout(() =&gt; {\n      dispatch(addTodo(title));\n    }, 1000);\n  };\n}\n</code></pre>\n<p>同期 ActionCreator はActionオブジェクトを返しています。</p>\n<p>非同期 ActionCreator は関数を返しています。\nthunkミドルウェアにより、通常のActionオブジェクト以外に関数を返せるようになります。\nここで返した関数は、引数としてdispatch関数とgetState関数を取ります。</p>\n<p>dispatch関数はActionオブジェクトを受け取りさえすれば、同期的にreducerに処理を移します。</p>\n<p>dispatch関数にさらに関数を渡すこともできます。このときも関数の引数としてdispatch関数とgetState関数を取ります。</p>\n<p>ポイント\n:   Reduxアプリでは、最終的にdispatch関数にActionオブジェクトを渡せばreducerに処理が移るという原則がある。</p>\n<h3 id="thunk-promise-async-await">thunk と Promise、Async/Await</h3>\n<p>Promise\n:   </p>\n<pre><code>~~~javascript\nconst sleep1000ms = () =&gt; {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve();\n    }, 1000);\n  });\n};\n\nexport function addTodo(title) {\n  return {\n    type: types.ADD_TODO,\n    payload: {\n      id: shortid.generate(),\n      title,\n    },\n  };\n}\n\n// Promise 版\nexport function asyncAddTodo(title) {\n  return (dispatch) =&gt; {\n    sleep1000ms().then(() =&gt; {\n      dispatch(addTodo(title));\n    });\n  };\n}\n~~~\n</code></pre><p>Async/Await\n:   </p>\n<pre><code>~~~javascript\nconst sleep1000ms = () =&gt; {\n  ... 上記サンプルと同じ\n};\n\nexport function addTodo(title) {\n  ... 上記サンプルと同じ\n}\n\n// Async/Await 版\nexport function asyncAddTodo(title) {\n  return async(dispatch) =&gt; {\n    await sleep1000ms();\n    dispatch(addTodo(title));\n  };\n}\n~~~\n</code></pre><h3 id="-">複数のアクションをまとめる</h3>\n<p>通常のActionCreatorでは、1つの関数では1つのActionしか返せませんでした。\nthunkはこれらを1つにまとめたActionとして返すことができます。</p>\n<pre><code class="lang-javascript">function addTodo(title) {\n  return {\n    type: types.ADD_TODO,\n    payload: {\n      id: shortid.generate(),\n      title,\n    },\n  };\n}\n\nfunction updateInput(value) {\n  return {\n    type: types.UPDATE_INPUT,\n    payload: {\n      value,\n    },\n  };\n}\n\n// 上の2つのActionを1つにまとめる\n// これをReactコンポーネントにバインドする\nexport function addTodoAndClear(title) {\n  return (dispatch) =&gt; {\n    dispatch(addTodo(title));\n    dispatch(updateInput(&#39;&#39;));\n  };\n}\n</code></pre>\n<p>1つの操作で複数の処理を行うときのアプローチとして、以下が考えられます。</p>\n<ul>\n<li>ActionCreatorでまとめる。</li>\n<li>1つのActionとして記述し、reducerで2つの操作を行う。</li>\n<li>複数のActionをReactコンポーネントのボタンにバインドする。</li>\n</ul>\n<p>ActionCreatorでまとめるのがベターな方法です。\n理由は次の2つです。</p>\n<ol>\n<li><p>それぞれのActionの処理を独立して考えられる。</p>\n<p> サンプルコードの場合、TODOを追加することと、フォームをクリアすることに直接の関係はありません。\n TODOをコピーするときなどフォームを使わずにTODOを追加する方法を増やすときは、addTodo関数については再利用ができそうです。</p>\n</li>\n<li><p>ActionCreatorをユーザー操作とひも付けられる。</p>\n<p> ActionCreatorはContainerコンポーネントからpropsとしてUI要素を持つプレゼンテーショナルコンポーネントに渡されるはずです。\n このとき、プレゼンテーショナルコンポーネントは「このボタンを押すと何が起きるかはわからないが、渡された関数を叩けばよい」というように作られているべきです。</p>\n<p> ボタンを押したら「TODOを追加する関数を叩く」のと「フォームをクリアする関数を叩く」ことをプレゼンテーショナルコンポーネントに書いてしまうと、コンポーネントはビジネスロジックや仕様を反映し、汎用性を失ってしまいます。</p>\n</li>\n</ol>\n<h3 id="getstate-">getState関数</h3>\n<p>getState関数はstoreが持つ関数と同一で、すべてのstateを返します。\nActionCreator内でstoreの内容を知ることで、できることが広がります。</p>\n<p>たとえば、登録済みのTODOは追加しないようにする。など。</p>\n<pre><code class="lang-javascript">export function addUniqueTodo(title) {\n  return (dispatch, getState) =&gt; {\n    const {\n      todo: {\n        todos,\n      },\n    } = getState();\n\n    // stateに保存されたTodoに同一のタイトルがあったら登録済み\n    const isDuplicated = todos.some(todo =&gt; todo.title === title);\n\n    if (isDuplicated) {\n      return;\n    }\n    dispatch(addTodo(title));\n  };\n}\n</code></pre>\n<p>この処理はReducerでもできますが、ActionCreatorで処理すると次のメリットがあります。</p>\n<ol>\n<li><p>すべてのstateを参照できる</p>\n<p> 分割されたReducerは、ほかのReducerが持っているstateを参照することができません。\n ほかのReducerが持っているstateを使ってActionの動作を振り分けたいときは、ActionCreatorでgetStateするのがよいでしょう。</p>\n</li>\n<li><p>Action、Reducerの処理を簡潔にできる</p>\n<p> 〝ActionをどうDispatchするか〟の部分をActionCreatorとして切り出しておくことで、アクションとそれに対応するReducerの処理を簡潔にできます。</p>\n</li>\n</ol>\n<h2 id="ui-">UIをきれいにする</h2>\n<h3 id="style-">style属性を使う方法</h3>\n<p>※style属性を使っての指定は非推奨です。</p>\n<ul>\n<li>JSXのstyle属性を使って、直接スタイルを適用できる。</li>\n<li>オブジェクトのキーにCSSプロパティをキャメルケースで指定、オブジェクトの値にCSSの値を指定します。</li>\n<li><p>値にNumber型を指定したときは自動でpxが追加されます。px以外の単位を指定するときは、単位付きの値を文字列で指定します。</p>\n<pre><code class="lang-javascript">  // font-size: 20px\n  &lt;div style={{ fontSize: 20 }}&gt;\n    Hello World\n  &lt;/div&gt;\n\n  // font-size: 2em\n  &lt;div style={{ fontSize: &quot;2em&quot; }}&gt;\n    Hello World\n  &lt;/div&gt;\n</code></pre>\n</li>\n<li><p>ベンダープレフィクスは自動で付与されません。自分で指定する必要があります。</p>\n<pre><code class="lang-javascript">  const style = {\n    // ベンダープレフィクス付きのスタイル\n    WebkitTransition: &quot;all&quot;,\n    // 通常のスタイル\n    transition: &quot;all&quot;\n  };\n\n  const HelloWorldComponent = () =&gt; {\n    return &lt;div style={ style }&gt;Hello World&lt;/div&gt;\n  }\n</code></pre>\n</li>\n</ul>\n<h3 id="classname-">className属性を使う方法</h3>\n<p>JSXのclassName属性を使って、CSSクラスの指定ができます。className属性に指定した内容が、HTMLのclass属性となります。</p>\n<pre><code class="lang-javascript">const Button = () =&gt; {\n  return &lt;button className=&quot;normal-button&quot;&gt;追加&lt;/button&gt;\n}\n</code></pre>\n\x3c!-- TODO: p.169 リスト9.4　<button>要素で始まっているのに、閉じタグが</div>　リスト9.6も同様 --\x3e\n<p><code>webpack</code>、<code>css-loader</code>、<code>style-loader</code>などのライブラリを組み合わせることで、JavaScriptからCSSファイルの読み込みができるようになります。\n<code>create-react-app</code>では、標準でCSSファイルのインポートがサポートされています。</p>\n<pre><code class="lang-javascript">import &quot;./style.css&quot;;\n\nconst Button = () =&gt;\n  &lt;button className=&quot;normal-button&quot;&gt;追加&lt;/button&gt;;\n\nexport default Button;\n</code></pre>\n<h3 id="ui-">UIライブラリを使う</h3>\n<ul>\n<li><p>Material-UI</p>\n<p>  マテリアルデザインに沿って作られたUIライブラリ。</p>\n</li>\n<li><p>React-Bootstrap</p>\n<p>  BootstrapをReact向けのUIライブラリとして実装したもの。</p>\n</li>\n<li><p>React Desktop</p>\n<p>  デスクトップネイティブアプリの開発を想定したReact向けUIライブラリ。\n  Electronなどで利用します。</p>\n</li>\n<li><p>Onsen UI</p>\n<p>  ネイティブアプリライクなモバイルウェブアプリの作成に特化したUIライブラリ。</p>\n</li>\n</ul>\n<h3 id="material-ui">Material-UI</h3>\n<p>マテリアルデザインに則ったUIを簡単に実装することができます。\nボタンやフォームなどの基本的なUIパーツが網羅されています。</p>\n<p>各UIパーツはReactコンポーネントとして実装されており、props経由でコンポーネントをカスタマイズできます。</p>\n<p>パッケージは、次のコマンドでインストールできます。</p>\n<p>こちらだと v0.20.0 がインストールされます。</p>\n<pre><code>&gt; npm install --save material-ui\n</code></pre><p>最新をインストールしたければ次のコマンドにします。\n2018年3月8日時点で v1.0.0-beta.36がインストールされました。</p>\n<pre><code>&gt; npm install --save material-ui@next\n</code></pre><p>※以降のサンプルは<code>@next</code>でインストールしたものを対象としています。</p>\n<h4 id="-">使い方</h4>\n<p><code>src/components/TodoApp.js</code>を修正します。</p>\n<ol>\n<li><p>インポートを追加します。</p>\n<pre><code class="lang-javascript"> import Reboot from &#39;material-ui/Reboot&#39;;\n import Button from &#39;material-ui/Button&#39;;\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>Rebootコンポーネントを追加します。\n 場所はどこでもよいですが、今回はルート要素の最初の子要素にしました。</p>\n<pre><code class="lang-javascript"> export default function TodoApp({ task, tasks, inputTask, addTask, redirectToError }) {\n   return (\n     &lt;div&gt;\n       &lt;input type=&quot;text&quot; onChange={(e) =&gt; inputTask(e.target.value)} /&gt;\n</code></pre>\n<p>  ↓</p>\n<pre><code class="lang-javascript"> export default function TodoApp({ task, tasks, inputTask, addTask, redirectToError }) {\n   return (\n     &lt;div&gt;\n       &lt;Reboot /&gt;\n       &lt;input type=&quot;text&quot; onChange={(e) =&gt; inputTask(e.target.value)} /&gt;\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>input要素で作っていたボタンを、Buttonコンポーネントに変更します。</p>\n<pre><code class="lang-javascript"> &lt;input type=&quot;button&quot; value=&quot;add&quot; onClick={() =&gt; addTask(task)} /&gt;\n</code></pre>\n<p> ↓</p>\n<pre><code class="lang-javascript"> &lt;Button variant=&quot;raised&quot; className=&quot;default&quot; onClick={() =&gt; addTask(task)}&gt;add&lt;/Button&gt;\n</code></pre>\n</li>\n</ol>\n<h2 id="note">Note</h2>\n<h3 id="redux-">Reduxの三原則</h3>\n<p>Single source of truth\n:   アプリケーション内のすべての状態を一つの大きなオブジェクトとして管理します。</p>\n<p>State in read-only\n:   アプリケーションの状態はコンポーネントから直接参照できますが、直接変更することはできません。\n    Action（どんな動作を行ったのかを示す単純なオブジェクト）をdispatch（発行）することが、アプリケーションの状態を変更する唯一の方法です。</p>\n<p>Changes are made with pure functions\n:   アプリケーションの状態の変更は、副作用のない純粋関数によって行われます。\n    〝純粋関数〟とは〝同じ入力を渡せば、同じ出力が得られる関数〟のことです。</p>\n<h3 id="ie11-array-prototype-find-">IE11 Array.prototype.find メソッドがエラーになる</h3>\n<p>IE11 では Array.prototype.find メソッドがサポートされていないのでエラーになります。</p>\n<p>対応させるためには Polyfill で代替コードを実装する必要があります。</p>\n<h2 id="-">一連の流れを通しで</h2>\n<ol>\n<li><p>プロジェクトを作成して、ルートフォルダに移動します。</p>\n<pre><code> &gt; .\\node_modules\\.bin\\create-react-app app-1st\n &gt; cd app-1st\n</code></pre></li>\n<li><p>propTypesをインストールします。</p>\n<pre><code> &gt; npm install --save prop-types\n</code></pre><p> propTypesはpropsの型チェック機能を持つパッケージです。</p>\n</li>\n</ol>\n<ol>\n<li><p>アプリケーションを開発モードで起動します。</p>\n<p> ブラウザが自動で起動して、<code>http://localhost:3000/</code>にアクセスします。</p>\n<pre><code> &gt; npm start\n</code></pre></li>\n<li><p>ファイル/フォルダ構成に則り、フォルダを作ります。\n あとから作り直せばいいので、構成はあまり悩まなくてよいです。</p>\n<p> 今回はサンプルと同じにします。</p>\n<pre><code> src/\n +---index.js  ... エントリポイント\n +---App.js    ... ルートコンポーネント\n +---components/\n |     ... Presentational Component を置く\n +---containers/\n |     ... Container Component を置く\n +---actions/\n |     ... ActionCreator を置く\n +---reducers/\n |     ... Reducer を置く\n `---store/\n       ... Store を置く（createStore関数）\n</code></pre><pre><code> &gt; mkdir .\\src\\containers\n &gt; mkdir .\\src\\components\n &gt; mkdir .\\src\\actions\n &gt; mkdir .\\src\\reducers\n &gt; mkdir .\\src\\store\n</code></pre></li>\n</ol>\n<ol>\n<li><p>Reduxをインストールします。</p>\n<p> Reduxを開発で使う場合、開発が進んでからインストールするのは導入コストが高くなるため、開発開始時に導入しておきます。</p>\n<pre><code> &gt; npm install --save redux react-redux redux-logger\n</code></pre><p> ReduxのStoreの作成にはReducerが必要です。\n ［<code>src\\reducers\\index.js</code>］にReducerを追加します。</p>\n<p> この時点では、単純に受け取ったstateをそのまま返すReducerを定義しておきます。</p>\n<p> 1つのReducerでアプリケーションが完結することはまずないので、［<code>src\\reducers\\index.js</code>］に各Reducerの参照を束ねて、<code>import * as reducers from &quot;./reducers&quot;</code>でまとめてimportできる作りにしておきます。</p>\n<pre><code class="lang-javascript"> // 受け取ったstateをそのまま返すReducer\n export const noop = (state = {}) =&gt; state;\n</code></pre>\n<p> [<code>src\\store\\index.js</code>]にreduxのcreateStore関数を定義します。</p>\n<pre><code class="lang-javascript"> import { createStore, combineReducers, applyMiddleware } from &#39;redux&#39;;\n import logger from &#39;redux-logger&#39;;\n import * as reducers from &#39;../reducers&#39;;\n\n // Storeを生成するための関数を定義\n export default function createStoreEx() {\n   return createStore(\n     // 複数のReducerをまとめる\n     combineReducers(reducers),\n     // ミドルウェアを適用する\n     applyMiddleware(logger)\n   );\n }\n</code></pre>\n<p> ［<code>src\\index.js</code>］でStoreを生成し、react-reduxのProviderコンポーネントでAppコンポーネントに関連付ける処理を記述します。</p>\n<pre><code class="lang-javascript"> import React from &#39;react&#39;;\n import ReactDOM from &#39;react-dom&#39;;\n import { Provider } from &#39;react-redux&#39;;\n import App from &#39;./App&#39;;\n import createStoreEx from &#39;./store&#39;;\n\n // Storeの生成\n const store = createStoreEx();\n\n ReactDOM.render(\n   // Providerコンポーネントを使って、StoreをAppコンポーネントに関連付ける\n   &lt;Provider store={store}&gt;\n     &lt;App /&gt;\n   &lt;/Provider&gt;,\n   document.getElementById(&#39;root&#39;)\n );\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>ルーティングライブラリの導入</p>\n<p> こちらも開発開始時に導入しておきます。</p>\n<p> Note\n :   最新版の React Router （ver 4.x）に対応した react-router-redux パッケージのバージョンは ver 5.x なので、<code>@next</code>をつけてインストールします（2018年3月8日時点）。</p>\n<pre><code> &gt; npm install --save react-router-dom history react-router-redux@next\n</code></pre></li>\n</ol>\n<pre><code>Storeを生成する関数に、routerReducerとrouterMiddlewareを追加します。\n\n[`src\\store\\index.js`]\n\n~~~javascript\nimport { createStore, combineReducers, applyMiddleware } from &#39;redux&#39;;\nimport logger from &#39;redux-logger&#39;;\nimport * as reducers from &#39;../reducers&#39;;\nimport { routerReducer, routerMiddleware } from &#39;react-router-redux&#39;;\n\n// Storeを生成するための関数を定義\n// history は src/index.js から受け渡す\nexport default function createStoreEx(history) {\n  return createStore(\n    // 複数のReducerをまとめる\n    //   ・自前で定義したReducer\n    //   ・react-router-redux の Reducer\n    combineReducers({\n      ...reducers,\n      router: routerReducer,\n    }),\n    // ミドルウェアを適用する\n    // react-router-redux の Redux Middleware\n    applyMiddleware(\n      logger,\n      routerMiddleware(history)\n    )\n  );\n}\n~~~\n\n[`src\\index.js`]\n\n~~~javascript\nimport React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport { Provider } from &#39;react-redux&#39;;\nimport { ConnectedRouter } from &#39;react-router-redux&#39;;\nimport createBrowserHistory from &#39;history/createBrowserHistory&#39;;\nimport App from &#39;./App&#39;;\nimport createStoreEx from &#39;./store&#39;;\n\n// history のインスタンスを生成\nconst history = createBrowserHistory();\n\n// Storeの生成\nconst store = createStoreEx(history);\n\nReactDOM.render(\n  // Providerコンポーネントを使って、StoreをAppコンポーネントに関連付ける\n  &lt;Provider store={store}&gt;\n    {\n      /* Link コンポーネントなどが動作するように、\n         react-router-dom の Router ではなく\n         react-router-redux の ConnectedRouter を使う\n       */\n    }\n    &lt;ConnectedRouter history={history}&gt;\n      &lt;App /&gt;\n    &lt;/ConnectedRouter&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n~~~\n</code></pre><ol>\n<li><p>ルーティングの実装</p>\n<p> コンポーネントを作ります。</p>\n<p> [<code>src\\components\\Ranking.js</code>]</p>\n<pre><code class="lang-javascript"> import React from &#39;react&#39;;\n import PropTypes from &#39;prop-types&#39;;\n\n export default function Ranking({ categoryId }) {\n   // TODO: 最終的には categoryId をもとにAPIから情報を取得する\n   return (\n     &lt;div&gt;\n       &lt;h2&gt;Ranking Component&lt;/h2&gt;\n       &lt;p&gt;Category Id: {categoryId}&lt;/p&gt;\n     &lt;/div&gt;\n   )\n }\n\n // propsのデータ型を定義\n Ranking.propTypes = {\n   categoryId: PropTypes.string\n };\n\n // 未指定時の既定値を定義\n Ranking.defaultProps = {\n   categoryId: &quot;1&quot;\n };\n</code></pre>\n<p> ルーティングの設定は [<code>src\\App.js</code>] に記述します。</p>\n<pre><code class="lang-javascript"> import React, { Component } from &#39;react&#39;;\n import { Route, Link } from &#39;react-router-dom&#39;;\n import Ranking from &#39;./components/Ranking&#39;;\n\n class App extends Component {\n   render() {\n     return (\n       &lt;div className=&quot;App&quot;&gt;\n         { /* カテゴリ名、IDはハードコード。本来であればAPIから取得するのが望ましい。 */ }\n         &lt;ul&gt;\n           &lt;li&gt;&lt;Link to=&quot;/all&quot;&gt;Category All&lt;/Link&gt;&lt;/li&gt;\n           &lt;li&gt;&lt;Link to=&quot;/category/2502&quot;&gt;Category 2502&lt;/Link&gt;&lt;/li&gt;\n           &lt;li&gt;&lt;Link to=&quot;/category/10002&quot;&gt;Category 10002&lt;/Link&gt;&lt;/li&gt;\n         &lt;/ul&gt;\n\n         &lt;Route path=&quot;/all&quot; component={Ranking} /&gt;\n         &lt;Route\n           path=&quot;/category/:id&quot;\n           render={\n             ({ match }) =&gt; &lt;Ranking categoryId={match.params.id} /&gt;\n           } /&gt;\n       &lt;/div&gt;\n     );\n   }\n }\n\n export default App;\n</code></pre>\n</li>\n</ol>\n<ol>\n<li><p>非同期処理の実装</p>\n<p> インストール</p>\n<pre><code> &gt; npm install --save redux-thunk fetch-jsonp qs\n</code></pre><p> fetch-jsonp\n :   XMLHttpRequestの後継であるfetch関数と同じインターフェースでJSONPのAPIで通信できるライブラリ。</p>\n<p> qs\n :   URLのクエリ文字列（URLの ? のあとにつく key=value&amp;hoge=fuga の部分）を扱うライブラリ。</p>\n<p> ミドルウェアに redux-thunk を追加するため、[<code>src\\store\\index.js</code>]を修正します。</p>\n<pre><code class="lang-javascript"> import { createStore, combineReducers, applyMiddleware } from &#39;redux&#39;;\n import logger from &#39;redux-logger&#39;;\n import thunk from &#39;redux-thunk&#39;;\n import * as reducers from &#39;../reducers&#39;;\n import { routerReducer, routerMiddleware } from &#39;react-router-redux&#39;;\n\n // Storeを生成するための関数を定義\n // history は src/index.js から受け渡す\n export default function createStoreEx(history) {\n   return createStore(\n     // 複数のReducerをまとめる\n     //   ・自前で定義したReducer\n     //   ・react-router-redux の Reducer\n     combineReducers({\n       ...reducers,\n       router: routerReducer,\n     }),\n     // ミドルウェアを適用する\n     // react-router-redux の Redux Middleware\n     applyMiddleware(\n       logger,\n       thunk,\n       routerMiddleware(history)\n     )\n   );\n }\n</code></pre>\n<p> APIからデータを取得し、ReduxのStoreを経由してコンポーネントに表示する処理を実装します。</p>\n<p> ComponentからActionを呼び出す部分。</p>\n<p> [<code>src\\components\\Ranking.js</code>]</p>\n<pre><code class="lang-javascript"> import React from &#39;react&#39;;\n import PropTypes from &#39;prop-types&#39;;\n\n // ライフサイクルメソッドを使うので function から class に変更\n export default class Ranking extends React.Component {\n\n   componentWillMount() {\n     this.props.onMount(this.props.categoryId);\n   }\n\n   componentWillReceiveProps(nextProps) {\n     if (this.props.categoryId !== nextProps.categoryId) {\n       // props.categoryId に変化があるので、ページ移動が発生している\n       this.props.onUpdate(nextProps.categoryId);\n     }\n   }\n\n   // TODO: 最終的には categoryId をもとにAPIから情報を取得する\n   render() {\n     return (\n       &lt;div&gt;\n         &lt;h2&gt;Ranking Component&lt;/h2&gt;\n         &lt;p&gt;Category Id: {this.props.categoryId}&lt;/p&gt;\n       &lt;/div&gt;\n     );\n   }\n }\n\n // propsのデータ型を定義\n Ranking.propTypes = {\n   categoryId: PropTypes.string,\n   onMount: PropTypes.func.isRequired,\n   onUpdate: PropTypes.func.isRequired\n };\n\n // 未指定時の既定値を定義\n Ranking.defaultProps = {\n   categoryId: &quot;1&quot;\n };\n</code></pre>\n<p> [<code>src\\actions\\Ranking.js</code>]</p>\n<p> ActionCreator を定義します。</p>\n<ul>\n<li>コンポーネントのprops.onMount、props.onUpdateが呼び出されたときに実行するfetchRanking\n  ※redux-thunkを使った非同期処理</li>\n<li>リクエスト開始 Action - startRequest</li>\n<li>レスポンス受信 Action - receiveData</li>\n<li><p>リクエスト完了 Action - finishRequest</p>\n<pre><code class="lang-javascript">import fetchJsonp from &#39;fetch-jsonp&#39;;\nimport qs from &#39;qs&#39;;\n\nconst API_URL = &quot;http://hoge.co.jp/v1/json/hoge&quot;; // TODO: api のURL\nconst APP_ID = &quot;APP_ID&quot;;                          // TODO: 不要だが定義しておく\n\n// リクエスト開始 Action\nconst startRequest = categoryId =&gt; ({\ntype: &quot;START_REQUEST&quot;,\npayload: { categoryId },\n});\n\n// レスポンス受信 Action\nconst receiveData = (categoryId, error, response) =&gt; ({\ntype: &quot;RECEIVE_DATA&quot;,\npayload: { categoryId, error, response },\n});\n\n// リクエスト完了 Action\nconst finishRequest = categoryId =&gt; ({\ntype: &quot;FINISH_REQUEST&quot;,\npayload: { categoryId },\n});\n\n// データ取得\nexport const fetchRanking = categoryId =&gt; {\n// redux-thunkを使った非同期処理\nreturn async dispatch =&gt; {\n  dispatch(startRequest(categoryId));\n\n  const queryString = qs.stringify({\n    appid: APP_ID,\n    category_id: categoryId,\n  });\n\n  try {\n    const response = await fetchJsonp(`${API_URL}?${queryString}`);\n    const data = await response.json();\n    dispatch(receiveData(categoryId, null, data));\n\n  } catch (ex) {\n    dispatch(receiveData(categoryId, ex));\n  }\n\n  dispatch(finishRequest(categoryId));\n};\n};\n</code></pre>\n<p>[<code>src\\containers\\Ranking.js</code>]</p>\n</li>\n<li><p>ActionCreator をコンポーネントのprops.onMountedから呼び出すため、Container Component を定義します。</p>\n</li>\n<li><p>mapDispatchToPropsで、props.onMountedとactions.fetchRankingを接続します。</p>\n<pre><code class="lang-javascript">import { connect } from &#39;react-redux&#39;;\nimport Ranking from &#39;../components/Ranking&#39;;\nimport * as actions from &#39;../actions/Ranking&#39;;\n\n// TODO: Reducerを定義するまでの仮の処理\nconst mapStateToProps = (state, ownProps) =&gt; ({\ncategoryId: ownProps.categoryId\n});\n\nconst mapDispatchToProps = dispatch =&gt; ({\nonMount(categoryId) {\n  dispatch(actions.fetchRanking(categoryId));\n},\nonUpdate(categoryId) {\n  dispatch(actions.fetchRanking(categoryId));\n}\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Ranking);\n</code></pre>\n<p>[<code>src\\App.js</code>]</p>\n<p>定義したContainer Componentを使うように修正します。</p>\n<pre><code class="lang-javascript">import Ranking from &#39;./components/Ranking&#39;;\n</code></pre>\n<p>↓</p>\n<pre><code class="lang-javascript">import Ranking from &#39;./containers/Ranking&#39;;\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>Reducerの実装</p>\n<p> Reducerを実装し、取得したデータを表示します。</p>\n<ul>\n<li><p><code>src\\reducers\\shopping.js</code></p>\n<p>  カテゴリ名、カテゴリIDを保持する。\n  ランキングページにもカテゴリ名を表示したいので、<code>src\\App.js</code>のハードコードをこちらに移動する。</p>\n</li>\n<li><p><code>src\\reducers\\Ranking.js</code></p>\n<p>  Ranking コンポーネント用のReducer。\n  ランキング情報を保持します。</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>[`src\\reducers\\shopping.js`]\n\n固定のJSONを常に返すReducerとして実装します。\n\n※本来はAPIから取得した情報を返すようにするべきです。\n\n~~~javascript\nconst initialState = {\n  // カテゴリ情報\n  // 本来はAPIから取得した情報を返すべき\n  categories: [\n    {\n      id: &quot;1&quot;,\n      name: &quot;ALL&quot;\n    },\n    {\n      id: &quot;2502&quot;,\n      name: &quot;Category 2502&quot;\n    },\n    {\n      id: &quot;10002&quot;,\n      name: &quot;Category 10002&quot;\n    },\n  ]\n}\n\nexport default () =&gt; initialState;\n~~~\n\n\n[`src\\reducers\\Ranking.js`]\n\n- START_REQUEST Action にフックして、リクエスト開始時に状態をリセットします。\n- RECEIVE_DATA Action にフックして、レスポンスからランキング情報を取得し、状態に設定します。\n  リクエストが失敗したときはエラーフラグを立てます。\n- getRanking関数は、レスポンスから商品名、商品URL、商品画像のURLを抜き出します。\n\n~~~javascript\n// レスポンスからランキング情報だけを抜き出す\nconst getRanking = response =&gt; {\n  const ranking = [];\n  const itemLength = response.ResultSet.totalResultsReturned;\n  // TODO: p.206 ↑末尾にセミコロン必要では？\n  // TODO: ダウンロードできるサンプルに第10章が含まれていない\n\n  for (let index = 0; index &lt; itemLength; index++) {\n    const item = response.ResultSet[&#39;0&#39;].Result[index + &quot;&quot;];\n    ranking.push({\n      code: item.Code,\n      name: item.Name,\n      url: item.Url,\n      imageUrl: item.Image.Medium\n    });\n  }\n  return ranking;\n};\n\n\n// 初期状態\nconst initialState = {\n  categoryId: undefined,\n  ranking: undefined,\n  error: false\n};\n\n\nexport default (state = initialState, action) =&gt; {\n  switch (action.type) {\n    // リクエスト開始時に状態をリセット\n    case &quot;START_REQUEST&quot;:\n      return {\n        categoryId: action.payload.categoryId,\n        ranking: undefined,\n        error: false\n      };\n\n    // データ受信\n    case &quot;RECEIVE_DATA&quot;:\n      return action.payload.error\n        ? {\n            ...state, \n            error: true\n          }\n        : {\n            ...state,\n            ranking: getRanking(action.payload.response)\n          };\n\n    default:\n      return state;\n  }\n}\n~~~\n\n\n2つのReducerの参照を [`src\\reducers\\index.js`] に追加します。\n\n~~~javascript\n// 受け取ったstateをそのまま返すReducer\nexport const noop = (state = {}) =&gt; state;\n\nexport { default as shopping } from &#39;./shopping&#39;;\nexport { default as Ranking } from &#39;./Ranking&#39;;\n~~~\n\n\n[`src\\App.js`] のリンクの部分を Nav コンポーネントに移動する。\n\n[`src\\components\\Nav.js`]\n\n~~~javascript\nimport React from &#39;react&#39;;\nimport PropTypes from &#39;prop-types&#39;;\nimport { Link } from &#39;react-router-dom&#39;;\n\nexport default function Nav({ categories }) {\n  // 移動先パスの生成\n  //   カテゴリID = &quot;1&quot; であれば &quot;/all&quot;\n  //   上記以外であれば &quot;/category/&lt;カテゴリID&gt;&quot;\n  const to = category =&gt; (\n    category.id === &quot;1&quot;\n      ? &quot;/all&quot;\n      : `/category/${category.id}`\n  );\n\n  return (\n    &lt;ul&gt;\n      { /* props.categories からリンク一覧を生成 */ }\n      {categories.map(category =&gt; (\n        &lt;li key={`nav-item-${category.id}`}&gt;\n          &lt;Link to={to(category)}&gt;\n            {category.name}\n          &lt;/Link&gt;\n        &lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n\nNav.propTypes = {\n  // state.shopping.categories の構造\n  categories: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      name: PropTypes.string.isRequired\n    })\n  ).isRequired\n};\n~~~\n\n\nNav コンポーネントの Container Component を作成します。\n\n[`src\\containers\\Nav.js`]\n\n~~~javascript\nimport { connect } from &#39;react-redux&#39;;\nimport Nav from &#39;../components/Nav&#39;;\n\nconst mapStateToProps = state =&gt; ({\n  // state.shopping.categories を props.categories に関連付ける\n  categories: state.shopping.categories\n});\n\nexport default connect(mapStateToProps)(Nav);\n~~~\n\n\nApp コンポーネントに Nav コンポーネントを組み込みます。\n\n[`src\\App.js`]\n\n~~~javascript\nimport React, { Component } from &#39;react&#39;;\nimport { Route, Switch, Redirect } from &#39;react-router-dom&#39;;\nimport Ranking from &#39;./containers/Ranking&#39;;\nimport Nav from &#39;./containers/Nav&#39;;\n\nclass App extends Component {\n  render() {\n    return (\n      &lt;div className=&quot;App&quot;&gt;\n        { /* Nav コンポーネントに差し替える */ }\n        { /*\n        &lt;ul&gt;\n          &lt;li&gt;&lt;Link to=&quot;/all&quot;&gt;Category All&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to=&quot;/category/2502&quot;&gt;Category 2502&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to=&quot;/category/10002&quot;&gt;Category 10002&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        */ }\n        &lt;Nav /&gt;\n\n        &lt;Switch&gt;\n          &lt;Route path=&quot;/all&quot; component={Ranking} /&gt;\n          &lt;Route\n            path=&quot;/category/1&quot;\n            render={\n              () =&gt; &lt;Redirect to=&quot;/all&quot; /&gt;\n            } /&gt;\n          &lt;Route\n            path=&quot;/category/:id&quot;\n            render={\n              ({ match }) =&gt; &lt;Ranking categoryId={match.params.id} /&gt;\n            } /&gt;\n        &lt;/Switch&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;\n~~~\n</code></pre><ol>\n<li><p>機能拡張</p>\n<ul>\n<li>state.shopping.categoriesにないカテゴリIDへのアクセスは、トップページにリダイレクトする。</li>\n<li>カテゴリ名を表示</li>\n<li>ランキング情報の表示</li>\n</ul>\n<p>[<code>src\\actions\\Ranking.js</code>]</p>\n<pre><code class="lang-javascript">import fetchJsonp from &#39;fetch-jsonp&#39;;\nimport qs from &#39;qs&#39;;\nimport { replace } from &#39;react-router-redux&#39;;\n\nconst API_URL = &quot;http://hoge.co.jp/v1/json/hoge&quot;; // TODO: api のURL\nconst APP_ID = &quot;APP_ID&quot;;                          // TODO: 不要だが定義しておく\n\n// リクエスト開始 Action\n// categoryId ではなく category を含めるように変更\nconst startRequest = category =&gt; ({\n  type: &quot;START_REQUEST&quot;,\n  payload: { category },\n});\n\n// レスポンス受信 Action\n// categoryId ではなく category を含めるように変更\nconst receiveData = (category, error, response) =&gt; ({\n  type: &quot;RECEIVE_DATA&quot;,\n  payload: { category, error, response },\n});\n\n// リクエスト完了 Action\n// categoryId ではなく category を含めるように変更\nconst finishRequest = category =&gt; ({\n  type: &quot;FINISH_REQUEST&quot;,\n  payload: { category },\n});\n\n// データ取得\nexport const fetchRanking = categoryId =&gt; {\n  // redux-thunkを使った非同期処理\n  // getState関数を引数に追加する\n  return async (dispatch, getState) =&gt; {\n    // カテゴリIDに対応する state.shopping.categories の要素を取得\n    const categories = getState().shopping.categories;\n    const category = categories.find(category =&gt; (category.id === categoryId));\n\n    // 対応する情報がなければトップページへリダイレクト\n    if (typeof category === &quot;undefined&quot;) {\n      dispatch(replace(&quot;/&quot;));\n      return;\n    }\n\n    // startRequest Action の引数に category を受け渡す\n    dispatch(startRequest(category));\n\n    const queryString = qs.stringify({\n      appid: APP_ID,\n      category_id: categoryId,\n    });\n\n    try {\n      const response = await fetchJsonp(`${API_URL}?${queryString}`);\n      const data = await response.json();\n      dispatch(receiveData(category, null, data));  // categoryId ではなく category を受け渡す\n\n    } catch (ex) {\n      dispatch(receiveData(category, ex));  // categoryId ではなく category を受け渡す\n    }\n\n    dispatch(finishRequest(category));      // categoryId ではなく category を受け渡す\n  };\n};\n</code></pre>\n<p>修正したActionに対応できるように、Reducerを変更します。</p>\n<p>[<code>src\\reducers\\Ranking.js</code>] （変更する initialState の部分のみ抜粋）</p>\n<pre><code class="lang-javascript">// 初期状態\nconst initialState = {\n  // categoryId → category\n  category: undefined,\n  ranking: undefined,\n  error: false\n};\n</code></pre>\n<p>Rankingコンポーネントと Store の状態を関連付けます。</p>\n<p>[<code>src\\containers\\Ranking.js</code>] （mapStateToProps の部分のみ抜粋）</p>\n<pre><code class="lang-javascript">const mapStateToProps = (state, ownProps) =&gt; ({\n  categoryId: ownProps.categoryId,\n\n  // カテゴリ情報、ランキング情報を Ranking コンポーネントに渡す\n  category: state.Ranking.category,\n  ranking: state.Ranking.ranking,\n  error: state.Ranking.error\n});\n</code></pre>\n<p>Rankingコンポーネントは、受け取ったカテゴリ情報、ランキング情報、エラーフラグを表示します。</p>\n<p>[<code>src\\components\\Ranking.js</code>]</p>\n<pre><code class="lang-javascript">import React from &#39;react&#39;;\nimport PropTypes from &#39;prop-types&#39;;\n\nexport default class Ranking extends React.Component {\n\n  componentWillMount() {\n    this.props.onMount(this.props.categoryId);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.categoryId !== nextProps.categoryId) {\n      // props.categoryId に変化があるので、ページ移動が発生している\n      this.props.onUpdate(nextProps.categoryId);\n    }\n  }\n\n  render() {\n    const { category, ranking, error } = this.props;\n\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;{\n          typeof category !== &quot;undefined&quot;\n            ? `Ranking: ${category.name}`\n            : &quot;&quot;\n        }&lt;/h2&gt;\n\n        {(() =&gt; {\n          if (error) {\n            // エラー表示\n            return &lt;p&gt;エラーが発生しました。リロードしてください。&lt;/p&gt;;\n\n          } else if (typeof ranking === &quot;undefined&quot;) {\n            // リクエスト完了前\n            return &lt;p&gt;読み込み中...&lt;/p&gt;;\n\n          } else {\n            // ランキングの表示\n            return (\n              &lt;ol&gt;\n                {ranking.map(item =&gt; (\n                  &lt;li key={`ranking-item-${item.code}`}&gt;\n                    &lt;img alt={item.name} src={item.imageUrl} /&gt;\n                    &lt;a href={item.url} target=&quot;_blank&quot;&gt;{item.name}&lt;/a&gt;\n                  &lt;/li&gt;\n                ))}\n              &lt;/ol&gt;\n            );\n          }\n        })()}\n      &lt;/div&gt;\n    );\n  }\n}\n\n// propsのデータ型を定義\nRanking.propTypes = {\n  categoryId: PropTypes.string,\n  onMount: PropTypes.func.isRequired,\n  onUpdate: PropTypes.func.isRequired,\n\n  // category, ranking, error の型を追加\n  category: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n  }),\n  ranking: PropTypes.arrayOf(\n    PropTypes.shape({\n      code: PropTypes.string.isRequired,\n      name: PropTypes.string.isRequired,\n      url: PropTypes.string.isRequired,\n      imageUrl: PropTypes.string.isRequired\n    })\n  ),\n  error: PropTypes.bool.isRequired\n};\n\n// 未指定時の既定値を定義\nRanking.defaultProps = {\n  categoryId: &quot;1&quot;\n};\n</code></pre>\n</li>\n</ol>\n<h2 id="-">日付を扱う</h2>\n<p><code>react-moment</code>を使います。\n<code>moment</code>を使ったReactコンポーネントです。</p>\n<h3 id="-">インストール</h3>\n<pre><code>npm install --save moment react-moment\n</code></pre><p>タイムゾーンを指定するのであれば、こちらのパッケージもインストールします。</p>\n<pre><code>npm install --save moment-timezone\n</code></pre><h2 id="note-react-router">Note: React Router</h2>\n<p>Router\n:   すべてのRouterコンポーネントに共通する低レベルインターフェース。根底クラスみたいなもんだと思えばよいでしょう。</p>\n<pre><code>一般的にアプリでは次のRouterのうち、ひとつを使います。\n\n- BrowserRouter\n- HashRouter\n- MemoryRouter\n- NativeRouter\n- StaticRouter\n</code></pre><p>BrowserRouter\n:   HTML5 の history API を使って、URLとUIを同期するRouterコンポーネント。</p>\n<p>HashRouter\n:   URLのハッシュ（＝window.location.hash）を使って、URLとUIを同期するRouterコンポーネント。</p>\n<p>Link\n:   ナビゲーションコンポーネント。</p>\n<p>NavLink\n:   見た目（スタイルの属性）ができるLinkコンポーネント。</p>\n<p>Route\n:   パスと一致するときに、コンポーネントを描画するコンポーネント。</p>\n<pre><code>Renderコンポーネントを使って、コンポーネントを描画するには次の3つの方法があります。\nが、ほとんどのケースで使うことになるのは、`&lt;Route component&gt;`でしょう。\n\n- `&lt;Route component&gt;`\n\n    パスが一致したときに、指定したコンポーネントを描画します。\n\n    ~~~javascript\n    // Helloコンポーネントを描画\n    &lt;Route path=&quot;/hello&quot; component={Hello}/&gt;\n    ~~~\n\n- `&lt;Route render&gt;`\n\n    パスが一致したときに、render関数に従い描画します。\n\n    ~~~javascript\n    &lt;Route path=&quot;/hello&quot; render={() =&gt; &lt;div&gt;Hello&lt;/div&gt;}/&gt;\n    ~~~\n\n- `&lt;Route children&gt;`\n\n    パスが一致するかどうかを描画するときに使います。\n\n    `children`の関数の引数 `match`には、パスが一致したときはオブジェクト、それ以外は null が渡されます。\n\n    [`match`の詳細は公式ドキュメントを参照。](https://reacttraining.com/react-router/web/api/match){target=&quot;_blank&quot;}\n\n    ~~~javascript\n    &lt;ul&gt;\n      &lt;ListItemLink to=&quot;/somewhere&quot;/&gt;\n      &lt;ListItemLink to=&quot;/somewhere-else&quot;/&gt;\n    &lt;/ul&gt;\n\n    const ListItemLink = ({ to, ...rest }) =&gt; (\n      &lt;Route path={to} children={({ match }) =&gt; (\n        &lt;li className={match ? &#39;active&#39; : &#39;&#39;}&gt;\n          &lt;Link to={to} {...rest}/&gt;\n        &lt;/li&gt;\n      )}/&gt;\n    )\n    ~~~\n\n\nすべての方法で、次の3つのpropsが渡されます。\n\n- match\n- location\n- history\n</code></pre><h2 id="react-router-redux">React Router Redux</h2>\n<h3 id="-">基本的な考え方</h3>\n<ol>\n<li><p>history を作ります。<br> HTML5 の history API を使うか、URLハッシュを使うか選べます。</p>\n</li>\n<li><p>ミドルウェアを構築します。<br> ナビゲーションアクションのインターセプトとディスパッチのためのミドルウェアを構築。\n 噛み砕いて言うと？</p>\n</li>\n<li><p><code>createStore</code>関数にReducerとMiddlewareを適用します。<br> Reducerの指定は「router」キーに「routerReducer」を指定します。</p>\n</li>\n</ol>\n<pre><code class="lang-javascript">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nimport { createStore, combineReducers, applyMiddleware } from &#39;redux&#39;\nimport { Provider } from &#39;react-redux&#39;\n\nimport createHistory from &#39;history/createBrowserHistory&#39;\nimport { Route } from &#39;react-router&#39;\n\nimport { ConnectedRouter, routerReducer, routerMiddleware, push } from &#39;react-router-redux&#39;\n\nimport reducers from &#39;./reducers&#39; // Or wherever you keep your reducers\n\n// (1) history の生成\nconst history = createHistory()\n\n// (2) ミドルウェアを構築\nconst middleware = routerMiddleware(history)\n\n// (3) storeの生成\n//      ・Reducerを指定します。router キーに routerReducer を指定します。\n//      ・構築したミドルウェアを適用します。\nconst store = createStore(\n  combineReducers({\n    ...reducers,\n    router: routerReducer\n  }),\n  applyMiddleware(middleware)\n)\n\n// これでどこからでもナビゲーションのアクションを送信できます。\n// store.dispatch(push(&#39;/foo&#39;))\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    { /* ConnectedRouter は Provider コンポーネントに store を自動で使います */ }\n    &lt;ConnectedRouter history={history}&gt;\n      &lt;div&gt;\n        &lt;Route exact path=&quot;/&quot; component={Home}/&gt;\n        &lt;Route path=&quot;/about&quot; component={About}/&gt;\n        &lt;Route path=&quot;/topics&quot; component={Topics}/&gt;\n      &lt;/div&gt;\n    &lt;/ConnectedRouter&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;root&#39;)\n)\n</code></pre>\n<h2 id="head-">head要素内の各要素を書き換える</h2>\n<p>React Helmet パッケージを使います。</p>\n<h3 id="-">実施環境</h3>\n<ul>\n<li>react-helmet 5.2.0</li>\n</ul>\n<h3 id="-">インストール</h3>\n<pre><code>&gt; npm install --save react-helmet\n</code></pre><h3 id="-">使い方</h3>\n<ul>\n<li><code>react-helmet</code>パッケージをインポートします。</li>\n<li><code>Helmet</code>コンポーネントの子要素に書き換える要素を指定します。</li>\n</ul>\n<pre><code class="lang-javascript">import React from &quot;react&quot;;\nimport {Helmet} from &quot;react-helmet&quot;;\n\nclass Application extends React.Component {\n  render () {\n    return (\n        &lt;div className=&quot;application&quot;&gt;\n            &lt;Helmet&gt;\n                &lt;meta charSet=&quot;utf-8&quot; /&gt;\n                &lt;title&gt;My Title&lt;/title&gt;\n                &lt;link rel=&quot;canonical&quot; href=&quot;http://mysite.com/example&quot; /&gt;\n            &lt;/Helmet&gt;\n            ...\n        &lt;/div&gt;\n    );\n  }\n};\n</code></pre>\n'},{title:"GitHub Flavored Markdown の検証",datePublished:"2018-01-31T12:27+09:00",dateModified:"2018-01-31T16:48+09:00",id:"gfm-test",category:"雑記",contentHtml:'<h2 id="-">概要</h2>\n<p>使っている Marked.js が GitHub Flavored Markdown をどこまでサポートしているのか確かめます。</p>\n<h2 id="-level-2">見出し Level 2</h2>\n<h3 id="-level-3">見出し Level 3</h3>\n<h4 id="-level-4">見出し Level 4</h4>\n<h5 id="-level-5">見出し Level 5</h5>\n<h6 id="-level-6">見出し Level 6</h6>\n<h2 id="-">文字スタイル</h2>\n<p><strong>太字</strong></p>\n<p><em>斜体</em></p>\n<p><del>打ち消し線</del></p>\n<p><strong>太字と <em>斜体</em> です</strong></p>\n<h2 id="-">引用</h2>\n<blockquote>\n<p>When viewing a conversation, you can automatically quote text in a comment by highlighting the text, then typing r. You can quote an entire comment by clicking , then Quote reply. For more information about keyboard shortcuts, see &quot;Using keyboard shortcuts.&quot;</p>\n</blockquote>\n<h2 id="-">インラインコード</h2>\n<p><code>git status</code>コマンドを実行します。</p>\n<h2 id="-">コードブロック</h2>\n<pre><code class="lang-js">function sayHello() {\n  alert(&#39;Hello!&#39;);\n}\n</code></pre>\n<h2 id="-">リンク</h2>\n<p><a href="https://pages.github.com/">GitHub Pages</a></p>\n<h2 id="-">リスト</h2>\n<p>単なるリスト</p>\n<ul>\n<li>list 1</li>\n<li>list 2</li>\n<li>list 3</li>\n</ul>\n<p>順番付きリスト</p>\n<ol>\n<li>手順１</li>\n<li>手順２</li>\n<li>手順３</li>\n</ol>\n<p>ネストさせてみる</p>\n<ol>\n<li>First list item<ul>\n<li>First nested list item<ul>\n<li>Second nested list item</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Second list item</li>\n</ol>\n<p>任意の数から始めることもできます。</p>\n<ol>\n<li>100番目からスタート！</li>\n<li>その次</li>\n<li>その次の次</li>\n</ol>\n<h2 id="todo-">TODO リスト</h2>\n<ul>\n<li>[x] やること１</li>\n<li>[ ] やること２</li>\n<li>[ ] やること３</li>\n</ul>\n<h2 id="-">絵文字</h2>\n<p>@octocat :+1: This PR looks great - it&#39;s ready to merge! :shipit:</p>\n<h2 id="-">テーブル</h2>\n<p>パターン表</p>\n<table>\n<thead>\n<tr>\n<th>p1</th>\n<th>p2</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n'}]}},[[241,1,0]]]);